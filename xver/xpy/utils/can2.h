/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 37.0.7 Mon Apr  4 17:52:22 2022.
 */

#ifndef CAN2_H
#define CAN2_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CAN2_AMK1_ACTUAL_VALUES_1_FRAME_ID (0x283u)
#define CAN2_AMK1_ACTUAL_VALUES_2_FRAME_ID (0x285u)
#define CAN2_AMK1_SETPOINTS_1_FRAME_ID (0x184u)
#define CAN2_AMK2_ACTUAL_VALUES_1_FRAME_ID (0x284u)
#define CAN2_AMK2_ACTUAL_VALUES_2_FRAME_ID (0x286u)
#define CAN2_AMK2_SETPOINTS_1_FRAME_ID (0x185u)
#define CAN2_AMK3_ACTUAL_VALUES_1_FRAME_ID (0x287u)
#define CAN2_AMK3_ACTUAL_VALUES_2_FRAME_ID (0x289u)
#define CAN2_AMK3_SETPOINTS_1_FRAME_ID (0x188u)
#define CAN2_AMK4_ACTUAL_VALUES_1_FRAME_ID (0x288u)
#define CAN2_AMK4_ACTUAL_VALUES_2_FRAME_ID (0x290u)
#define CAN2_AMK4_SETPOINTS_1_FRAME_ID (0x189u)
#define CAN2_IVT_MSG_COMMAND_FRAME_ID (0x411u)
#define CAN2_IVT_MSG_RESPONSE_FRAME_ID (0x511u)
#define CAN2_IVT_MSG_RESULT_I_FRAME_ID (0x521u)
#define CAN2_IVT_MSG_RESULT_U1_FRAME_ID (0x522u)
#define CAN2_IVT_MSG_RESULT_U2_FRAME_ID (0x523u)
#define CAN2_IVT_MSG_RESULT_U3_FRAME_ID (0x524u)
#define CAN2_IVT_MSG_RESULT_T_FRAME_ID (0x525u)
#define CAN2_IVT_MSG_RESULT_W_FRAME_ID (0x526u)
#define CAN2_IVT_MSG_RESULT_AS_FRAME_ID (0x527u)
#define CAN2_IVT_MSG_RESULT_WH_FRAME_ID (0x528u)
#define CAN2_CHARGER_CONFIG_FRAME_ID (0x270u)
#define CAN2_CC_STATUS_FRAME_ID (0x250u)

/* Frame lengths in bytes. */
#define CAN2_AMK1_ACTUAL_VALUES_1_LENGTH (8u)
#define CAN2_AMK1_ACTUAL_VALUES_2_LENGTH (8u)
#define CAN2_AMK1_SETPOINTS_1_LENGTH (8u)
#define CAN2_AMK2_ACTUAL_VALUES_1_LENGTH (8u)
#define CAN2_AMK2_ACTUAL_VALUES_2_LENGTH (8u)
#define CAN2_AMK2_SETPOINTS_1_LENGTH (8u)
#define CAN2_AMK3_ACTUAL_VALUES_1_LENGTH (8u)
#define CAN2_AMK3_ACTUAL_VALUES_2_LENGTH (8u)
#define CAN2_AMK3_SETPOINTS_1_LENGTH (8u)
#define CAN2_AMK4_ACTUAL_VALUES_1_LENGTH (8u)
#define CAN2_AMK4_ACTUAL_VALUES_2_LENGTH (8u)
#define CAN2_AMK4_SETPOINTS_1_LENGTH (8u)
#define CAN2_IVT_MSG_COMMAND_LENGTH (8u)
#define CAN2_IVT_MSG_RESPONSE_LENGTH (8u)
#define CAN2_IVT_MSG_RESULT_I_LENGTH (6u)
#define CAN2_IVT_MSG_RESULT_U1_LENGTH (6u)
#define CAN2_IVT_MSG_RESULT_U2_LENGTH (6u)
#define CAN2_IVT_MSG_RESULT_U3_LENGTH (6u)
#define CAN2_IVT_MSG_RESULT_T_LENGTH (6u)
#define CAN2_IVT_MSG_RESULT_W_LENGTH (6u)
#define CAN2_IVT_MSG_RESULT_AS_LENGTH (6u)
#define CAN2_IVT_MSG_RESULT_WH_LENGTH (6u)
#define CAN2_CHARGER_CONFIG_LENGTH (4u)
#define CAN2_CC_STATUS_LENGTH (1u)

/* Extended or standard frame types. */
#define CAN2_AMK1_ACTUAL_VALUES_1_IS_EXTENDED (0)
#define CAN2_AMK1_ACTUAL_VALUES_2_IS_EXTENDED (0)
#define CAN2_AMK1_SETPOINTS_1_IS_EXTENDED (0)
#define CAN2_AMK2_ACTUAL_VALUES_1_IS_EXTENDED (0)
#define CAN2_AMK2_ACTUAL_VALUES_2_IS_EXTENDED (0)
#define CAN2_AMK2_SETPOINTS_1_IS_EXTENDED (0)
#define CAN2_AMK3_ACTUAL_VALUES_1_IS_EXTENDED (0)
#define CAN2_AMK3_ACTUAL_VALUES_2_IS_EXTENDED (0)
#define CAN2_AMK3_SETPOINTS_1_IS_EXTENDED (0)
#define CAN2_AMK4_ACTUAL_VALUES_1_IS_EXTENDED (0)
#define CAN2_AMK4_ACTUAL_VALUES_2_IS_EXTENDED (0)
#define CAN2_AMK4_SETPOINTS_1_IS_EXTENDED (0)
#define CAN2_IVT_MSG_COMMAND_IS_EXTENDED (0)
#define CAN2_IVT_MSG_RESPONSE_IS_EXTENDED (0)
#define CAN2_IVT_MSG_RESULT_I_IS_EXTENDED (0)
#define CAN2_IVT_MSG_RESULT_U1_IS_EXTENDED (0)
#define CAN2_IVT_MSG_RESULT_U2_IS_EXTENDED (0)
#define CAN2_IVT_MSG_RESULT_U3_IS_EXTENDED (0)
#define CAN2_IVT_MSG_RESULT_T_IS_EXTENDED (0)
#define CAN2_IVT_MSG_RESULT_W_IS_EXTENDED (0)
#define CAN2_IVT_MSG_RESULT_AS_IS_EXTENDED (0)
#define CAN2_IVT_MSG_RESULT_WH_IS_EXTENDED (0)
#define CAN2_CHARGER_CONFIG_IS_EXTENDED (0)
#define CAN2_CC_STATUS_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define CAN2_CHARGER_CONFIG_MSG_SET_ENABLED_DISABLE_CHOICE (0u)
#define CAN2_CHARGER_CONFIG_MSG_SET_ENABLED_ENABLE_CHOICE (1u)

#define CAN2_CC_STATUS_ENABLE_AMS_CHARGING_DISABLE_CHOICE (0u)
#define CAN2_CC_STATUS_ENABLE_AMS_CHARGING_ENABLE_CHOICE (1u)

/**
 * Signals in message amk1_actual_values_1.
 *
 * Periodic 5ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_amk1_actual_values_1_t {
    /**
     * System ready (SBM).
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_status_system_ready;

    /**
     * Error.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_status_error;

    /**
     * Warning.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_status_warning;

    /**
     * HV activation acknowledgment.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_status_quit_dc_on;

    /**
     * HV activation level.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_status_dc_on;

    /**
     * Controller enable acknowledgment.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_status_quit_inverter_on;

    /**
     * Controller enable level.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_status_inverter_on;

    /**
     * Derating (torque limitation active).
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_derating;

    /**
     * Actual speed value.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk1_actual_velocity;

    /**
     * Raw data for calculating 'actual torque current'.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk1_torque_current;

    /**
     * Raw data for calculating 'actual magnetizing current'.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk1_magnetizing_current;
};

/**
 * Signals in message amk1_actual_values_2.
 *
 * Periodic 5ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_amk1_actual_values_2_t {
    /**
     * Motor temperature.
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t amk1_temp_motor;

    /**
     * Cold plate temperature.
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t amk1_temp_inverter;

    /**
     * Diagnostic number.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t amk1_error_info;

    /**
     * IGBT temperature.
     *
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t amk1_temp_igbt;
};

/**
 * Signals in message amk1_setpoints_1.
 *
 * Periodic< 50ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_amk1_setpoints_1_t {
    /**
     * Controller enable.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_control_inverter_on;

    /**
     * HV activation.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_control_dc_on;

    /**
     * Driver enable.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_control_enable;

    /**
     * Remove error (Setpoints must have value 0).
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk1_control_error_reset;

    /**
     * Speed setpoint.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk1_target_velocity;

    /**
     * Positive torque limit.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk1_torque_limit_positiv;

    /**
     * Negative torque limit.
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk1_torque_limit_negativ;
};

/**
 * Signals in message amk2_actual_values_1.
 *
 * Periodic 5ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_amk2_actual_values_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_system_ready;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_warning;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_status_quit_dc_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_status_dc_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_status_quit_inverter_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_status_inverter_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_status_derating;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk2_actual_velocity;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk2_torque_current;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t amk2_magnetizing_current;
};

/**
 * Signals in message amk2_actual_values_2.
 *
 * Periodic 5ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_amk2_actual_values_2_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t amk2_temp_motor;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t amk2_temp_inverter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t amk2_error_info;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t amk2_temp_igbt;
};

/**
 * Signals in message amk2_setpoints_1.
 *
 * Periodic< 50ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_amk2_setpoints_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_control_inverter_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_control_dc_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_control_enable;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t amk2_control_error_reset;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t amk2_target_velocity;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t amk2_torque_limit_positiv;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t amk2_torque_limit_negativ;
};

/**
 * Signals in message amk3_actual_values_1.
 *
 * Periodic 5ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_amk3_actual_values_1_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message amk3_actual_values_2.
 *
 * Periodic 5ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_amk3_actual_values_2_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message amk3_setpoints_1.
 *
 * Periodic< 50ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_amk3_setpoints_1_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message amk4_actual_values_1.
 *
 * Periodic 5ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_amk4_actual_values_1_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message amk4_actual_values_2.
 *
 * Periodic 5ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_amk4_actual_values_2_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message amk4_setpoints_1.
 *
 * Periodic< 50ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_amk4_setpoints_1_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message IVT_msg_command.
 *
 * Event. IVT Initialization.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_ivt_msg_command_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message IVT_msg_response.
 *
 * Event. After IVT Initialization.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_ivt_msg_response_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message IVT_msg_result_I.
 *
 * Periodic 20ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_ivt_msg_result_i_t {
    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int64_t i_ts;
};

/**
 * Signals in message IVT_msg_result_U1.
 *
 * Periodic 60ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_ivt_msg_result_u1_t {
    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int64_t u_cells;
};

/**
 * Signals in message IVT_msg_result_U2.
 *
 * Periodic 60ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_ivt_msg_result_u2_t {
    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int64_t u_fuse;
};

/**
 * Signals in message IVT_msg_result_U3.
 *
 * Periodic 60ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_ivt_msg_result_u3_t {
    /**
     * Range: -
     * Scale: 0.001
     * Offset: 0
     */
    int64_t u_vehicle;
};

/**
 * Signals in message IVT_msg_result_T.
 *
 * Periodic 100ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_ivt_msg_result_t_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int64_t ivt_temperature;
};

/**
 * Signals in message IVT_msg_result_W.
 *
 * Periodic 30ms.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_ivt_msg_result_w_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int64_t w_ts;
};

/**
 * Signals in message IVT_msg_result_As.
 *
 * Event. Reset by AMS after charging.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_ivt_msg_result_as_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int64_t tsa_available_capacity;
};

/**
 * Signals in message IVT_msg_result_Wh.
 *
 * Event. Reset by AMS after charging.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_ivt_msg_result_wh_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int64_t tsa_used_energy;
};

/**
 * Signals in message charger_config.
 *
 * All signal values are as on the CAN bus.
 */
struct can2_charger_config_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t set_mux;

    /**
     * Chargers in series should be treated as one unit
     *
     * Range: 0..900 (0..900 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t msg_set_voltage_limit;

    /**
     * Chargers in series should be treated as one unit
     *
     * Range: 0..133 (0..13.3 A)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t msg_set_current_limit;

    /**
     * Chargers in series should be treated as one unit
     *
     * Range: 0..2559 (0..2559 W)
     * Scale: 1
     * Offset: 0
     */
    uint16_t msg_set_power_limit;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_set_enabled;

    /**
     * TODO: what is tome out time?
     *
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_set_time_out;
};

/**
 * Signals in message cc_status.
 *
 * 
 *
 * All signal values are as on the CAN bus.
 */
struct can2_cc_status_t {
    /**
     * signal that enables/informs AMS to start charging sequence
     *
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable_ams_charging;
};

/**
 * Pack message amk1_actual_values_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_amk1_actual_values_1_pack(
    uint8_t *dst_p,
    const struct can2_amk1_actual_values_1_t *src_p,
    size_t size);

/**
 * Unpack message amk1_actual_values_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_amk1_actual_values_1_unpack(
    struct can2_amk1_actual_values_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk1_actual_values_1_amk1_status_system_ready_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_1_amk1_status_system_ready_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_1_amk1_status_system_ready_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk1_actual_values_1_amk1_status_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_1_amk1_status_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_1_amk1_status_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk1_actual_values_1_amk1_status_warning_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_1_amk1_status_warning_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_1_amk1_status_warning_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk1_actual_values_1_amk1_status_quit_dc_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_1_amk1_status_quit_dc_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_1_amk1_status_quit_dc_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk1_actual_values_1_amk1_status_dc_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_1_amk1_status_dc_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_1_amk1_status_dc_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk1_actual_values_1_amk1_status_quit_inverter_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_1_amk1_status_quit_inverter_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_1_amk1_status_quit_inverter_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk1_actual_values_1_amk1_status_inverter_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_1_amk1_status_inverter_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_1_amk1_status_inverter_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk1_actual_values_1_amk1_derating_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_1_amk1_derating_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_1_amk1_derating_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk1_actual_values_1_amk1_actual_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_1_amk1_actual_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_1_amk1_actual_velocity_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk1_actual_values_1_amk1_torque_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_1_amk1_torque_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_1_amk1_torque_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk1_actual_values_1_amk1_magnetizing_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_1_amk1_magnetizing_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_1_amk1_magnetizing_current_is_in_range(int16_t value);

/**
 * Pack message amk1_actual_values_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_amk1_actual_values_2_pack(
    uint8_t *dst_p,
    const struct can2_amk1_actual_values_2_t *src_p,
    size_t size);

/**
 * Unpack message amk1_actual_values_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_amk1_actual_values_2_unpack(
    struct can2_amk1_actual_values_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk1_actual_values_2_amk1_temp_motor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_2_amk1_temp_motor_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_2_amk1_temp_motor_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk1_actual_values_2_amk1_temp_inverter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_2_amk1_temp_inverter_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_2_amk1_temp_inverter_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can2_amk1_actual_values_2_amk1_error_info_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_2_amk1_error_info_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_2_amk1_error_info_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk1_actual_values_2_amk1_temp_igbt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_actual_values_2_amk1_temp_igbt_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_actual_values_2_amk1_temp_igbt_is_in_range(int16_t value);

/**
 * Pack message amk1_setpoints_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_amk1_setpoints_1_pack(
    uint8_t *dst_p,
    const struct can2_amk1_setpoints_1_t *src_p,
    size_t size);

/**
 * Unpack message amk1_setpoints_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_amk1_setpoints_1_unpack(
    struct can2_amk1_setpoints_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk1_setpoints_1_amk1_control_inverter_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_setpoints_1_amk1_control_inverter_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_setpoints_1_amk1_control_inverter_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk1_setpoints_1_amk1_control_dc_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_setpoints_1_amk1_control_dc_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_setpoints_1_amk1_control_dc_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk1_setpoints_1_amk1_control_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_setpoints_1_amk1_control_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_setpoints_1_amk1_control_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk1_setpoints_1_amk1_control_error_reset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_setpoints_1_amk1_control_error_reset_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_setpoints_1_amk1_control_error_reset_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk1_setpoints_1_amk1_target_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_setpoints_1_amk1_target_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_setpoints_1_amk1_target_velocity_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk1_setpoints_1_amk1_torque_limit_positiv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_setpoints_1_amk1_torque_limit_positiv_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_setpoints_1_amk1_torque_limit_positiv_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk1_setpoints_1_amk1_torque_limit_negativ_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk1_setpoints_1_amk1_torque_limit_negativ_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk1_setpoints_1_amk1_torque_limit_negativ_is_in_range(int16_t value);

/**
 * Pack message amk2_actual_values_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_amk2_actual_values_1_pack(
    uint8_t *dst_p,
    const struct can2_amk2_actual_values_1_t *src_p,
    size_t size);

/**
 * Unpack message amk2_actual_values_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_amk2_actual_values_1_unpack(
    struct can2_amk2_actual_values_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk2_actual_values_1_amk2_system_ready_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_1_amk2_system_ready_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_1_amk2_system_ready_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk2_actual_values_1_amk2_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_1_amk2_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_1_amk2_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk2_actual_values_1_amk2_warning_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_1_amk2_warning_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_1_amk2_warning_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk2_actual_values_1_amk2_status_quit_dc_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_1_amk2_status_quit_dc_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_1_amk2_status_quit_dc_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk2_actual_values_1_amk2_status_dc_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_1_amk2_status_dc_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_1_amk2_status_dc_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk2_actual_values_1_amk2_status_quit_inverter_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_1_amk2_status_quit_inverter_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_1_amk2_status_quit_inverter_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk2_actual_values_1_amk2_status_inverter_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_1_amk2_status_inverter_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_1_amk2_status_inverter_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk2_actual_values_1_amk2_status_derating_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_1_amk2_status_derating_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_1_amk2_status_derating_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk2_actual_values_1_amk2_actual_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_1_amk2_actual_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_1_amk2_actual_velocity_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk2_actual_values_1_amk2_torque_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_1_amk2_torque_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_1_amk2_torque_current_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk2_actual_values_1_amk2_magnetizing_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_1_amk2_magnetizing_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_1_amk2_magnetizing_current_is_in_range(int16_t value);

/**
 * Pack message amk2_actual_values_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_amk2_actual_values_2_pack(
    uint8_t *dst_p,
    const struct can2_amk2_actual_values_2_t *src_p,
    size_t size);

/**
 * Unpack message amk2_actual_values_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_amk2_actual_values_2_unpack(
    struct can2_amk2_actual_values_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk2_actual_values_2_amk2_temp_motor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_2_amk2_temp_motor_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_2_amk2_temp_motor_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk2_actual_values_2_amk2_temp_inverter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_2_amk2_temp_inverter_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_2_amk2_temp_inverter_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can2_amk2_actual_values_2_amk2_error_info_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_2_amk2_error_info_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_2_amk2_error_info_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can2_amk2_actual_values_2_amk2_temp_igbt_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_actual_values_2_amk2_temp_igbt_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_actual_values_2_amk2_temp_igbt_is_in_range(int16_t value);

/**
 * Pack message amk2_setpoints_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_amk2_setpoints_1_pack(
    uint8_t *dst_p,
    const struct can2_amk2_setpoints_1_t *src_p,
    size_t size);

/**
 * Unpack message amk2_setpoints_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_amk2_setpoints_1_unpack(
    struct can2_amk2_setpoints_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk2_setpoints_1_amk2_control_inverter_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_setpoints_1_amk2_control_inverter_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_setpoints_1_amk2_control_inverter_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk2_setpoints_1_amk2_control_dc_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_setpoints_1_amk2_control_dc_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_setpoints_1_amk2_control_dc_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk2_setpoints_1_amk2_control_enable_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_setpoints_1_amk2_control_enable_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_setpoints_1_amk2_control_enable_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_amk2_setpoints_1_amk2_control_error_reset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_setpoints_1_amk2_control_error_reset_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_setpoints_1_amk2_control_error_reset_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can2_amk2_setpoints_1_amk2_target_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_setpoints_1_amk2_target_velocity_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_setpoints_1_amk2_target_velocity_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can2_amk2_setpoints_1_amk2_torque_limit_positiv_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_setpoints_1_amk2_torque_limit_positiv_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_setpoints_1_amk2_torque_limit_positiv_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can2_amk2_setpoints_1_amk2_torque_limit_negativ_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_amk2_setpoints_1_amk2_torque_limit_negativ_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_amk2_setpoints_1_amk2_torque_limit_negativ_is_in_range(uint16_t value);

/**
 * Pack message amk3_actual_values_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_amk3_actual_values_1_pack(
    uint8_t *dst_p,
    const struct can2_amk3_actual_values_1_t *src_p,
    size_t size);

/**
 * Unpack message amk3_actual_values_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_amk3_actual_values_1_unpack(
    struct can2_amk3_actual_values_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message amk3_actual_values_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_amk3_actual_values_2_pack(
    uint8_t *dst_p,
    const struct can2_amk3_actual_values_2_t *src_p,
    size_t size);

/**
 * Unpack message amk3_actual_values_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_amk3_actual_values_2_unpack(
    struct can2_amk3_actual_values_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message amk3_setpoints_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_amk3_setpoints_1_pack(
    uint8_t *dst_p,
    const struct can2_amk3_setpoints_1_t *src_p,
    size_t size);

/**
 * Unpack message amk3_setpoints_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_amk3_setpoints_1_unpack(
    struct can2_amk3_setpoints_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message amk4_actual_values_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_amk4_actual_values_1_pack(
    uint8_t *dst_p,
    const struct can2_amk4_actual_values_1_t *src_p,
    size_t size);

/**
 * Unpack message amk4_actual_values_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_amk4_actual_values_1_unpack(
    struct can2_amk4_actual_values_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message amk4_actual_values_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_amk4_actual_values_2_pack(
    uint8_t *dst_p,
    const struct can2_amk4_actual_values_2_t *src_p,
    size_t size);

/**
 * Unpack message amk4_actual_values_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_amk4_actual_values_2_unpack(
    struct can2_amk4_actual_values_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message amk4_setpoints_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_amk4_setpoints_1_pack(
    uint8_t *dst_p,
    const struct can2_amk4_setpoints_1_t *src_p,
    size_t size);

/**
 * Unpack message amk4_setpoints_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_amk4_setpoints_1_unpack(
    struct can2_amk4_setpoints_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message IVT_msg_command.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_ivt_msg_command_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_command_t *src_p,
    size_t size);

/**
 * Unpack message IVT_msg_command.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_ivt_msg_command_unpack(
    struct can2_ivt_msg_command_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message IVT_msg_response.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_ivt_msg_response_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_response_t *src_p,
    size_t size);

/**
 * Unpack message IVT_msg_response.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_ivt_msg_response_unpack(
    struct can2_ivt_msg_response_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message IVT_msg_result_I.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_ivt_msg_result_i_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_i_t *src_p,
    size_t size);

/**
 * Unpack message IVT_msg_result_I.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_ivt_msg_result_i_unpack(
    struct can2_ivt_msg_result_i_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int64_t can2_ivt_msg_result_i_i_ts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_ivt_msg_result_i_i_ts_decode(int64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_ivt_msg_result_i_i_ts_is_in_range(int64_t value);

/**
 * Pack message IVT_msg_result_U1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_ivt_msg_result_u1_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_u1_t *src_p,
    size_t size);

/**
 * Unpack message IVT_msg_result_U1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_ivt_msg_result_u1_unpack(
    struct can2_ivt_msg_result_u1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int64_t can2_ivt_msg_result_u1_u_cells_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_ivt_msg_result_u1_u_cells_decode(int64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_ivt_msg_result_u1_u_cells_is_in_range(int64_t value);

/**
 * Pack message IVT_msg_result_U2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_ivt_msg_result_u2_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_u2_t *src_p,
    size_t size);

/**
 * Unpack message IVT_msg_result_U2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_ivt_msg_result_u2_unpack(
    struct can2_ivt_msg_result_u2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int64_t can2_ivt_msg_result_u2_u_fuse_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_ivt_msg_result_u2_u_fuse_decode(int64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_ivt_msg_result_u2_u_fuse_is_in_range(int64_t value);

/**
 * Pack message IVT_msg_result_U3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_ivt_msg_result_u3_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_u3_t *src_p,
    size_t size);

/**
 * Unpack message IVT_msg_result_U3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_ivt_msg_result_u3_unpack(
    struct can2_ivt_msg_result_u3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int64_t can2_ivt_msg_result_u3_u_vehicle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_ivt_msg_result_u3_u_vehicle_decode(int64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_ivt_msg_result_u3_u_vehicle_is_in_range(int64_t value);

/**
 * Pack message IVT_msg_result_T.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_ivt_msg_result_t_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_t_t *src_p,
    size_t size);

/**
 * Unpack message IVT_msg_result_T.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_ivt_msg_result_t_unpack(
    struct can2_ivt_msg_result_t_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int64_t can2_ivt_msg_result_t_ivt_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_ivt_msg_result_t_ivt_temperature_decode(int64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_ivt_msg_result_t_ivt_temperature_is_in_range(int64_t value);

/**
 * Pack message IVT_msg_result_W.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_ivt_msg_result_w_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_w_t *src_p,
    size_t size);

/**
 * Unpack message IVT_msg_result_W.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_ivt_msg_result_w_unpack(
    struct can2_ivt_msg_result_w_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int64_t can2_ivt_msg_result_w_w_ts_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_ivt_msg_result_w_w_ts_decode(int64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_ivt_msg_result_w_w_ts_is_in_range(int64_t value);

/**
 * Pack message IVT_msg_result_As.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_ivt_msg_result_as_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_as_t *src_p,
    size_t size);

/**
 * Unpack message IVT_msg_result_As.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_ivt_msg_result_as_unpack(
    struct can2_ivt_msg_result_as_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int64_t can2_ivt_msg_result_as_tsa_available_capacity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_ivt_msg_result_as_tsa_available_capacity_decode(int64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_ivt_msg_result_as_tsa_available_capacity_is_in_range(int64_t value);

/**
 * Pack message IVT_msg_result_Wh.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_ivt_msg_result_wh_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_wh_t *src_p,
    size_t size);

/**
 * Unpack message IVT_msg_result_Wh.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_ivt_msg_result_wh_unpack(
    struct can2_ivt_msg_result_wh_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int64_t can2_ivt_msg_result_wh_tsa_used_energy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_ivt_msg_result_wh_tsa_used_energy_decode(int64_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_ivt_msg_result_wh_tsa_used_energy_is_in_range(int64_t value);

/**
 * Pack message charger_config.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_charger_config_pack(
    uint8_t *dst_p,
    const struct can2_charger_config_t *src_p,
    size_t size);

/**
 * Unpack message charger_config.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_charger_config_unpack(
    struct can2_charger_config_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_charger_config_set_mux_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_charger_config_set_mux_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_charger_config_set_mux_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can2_charger_config_msg_set_voltage_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_charger_config_msg_set_voltage_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_charger_config_msg_set_voltage_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can2_charger_config_msg_set_current_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_charger_config_msg_set_current_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_charger_config_msg_set_current_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can2_charger_config_msg_set_power_limit_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_charger_config_msg_set_power_limit_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_charger_config_msg_set_power_limit_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_charger_config_msg_set_enabled_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_charger_config_msg_set_enabled_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_charger_config_msg_set_enabled_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_charger_config_msg_set_time_out_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_charger_config_msg_set_time_out_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_charger_config_msg_set_time_out_is_in_range(uint8_t value);

/**
 * Pack message cc_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can2_cc_status_pack(
    uint8_t *dst_p,
    const struct can2_cc_status_t *src_p,
    size_t size);

/**
 * Unpack message cc_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can2_cc_status_unpack(
    struct can2_cc_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can2_cc_status_enable_ams_charging_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can2_cc_status_enable_ams_charging_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can2_cc_status_enable_ams_charging_is_in_range(uint8_t value);


#ifdef __cplusplus
}
#endif

#endif
