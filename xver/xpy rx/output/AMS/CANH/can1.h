/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 37.0.7 Wed Apr 27 19:24:12 2022.
 */

#ifndef CAN1_H
#define CAN1_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
#define CAN1_AMS_STATUS_1_FRAME_ID (0x20u)
#define CAN1_DV_DRIVING_DYNAMICS_1_FRAME_ID (0x500u)
#define CAN1_DV_DRIVING_DYNAMICS_2_FRAME_ID (0x501u)
#define CAN1_DV_SYSTEM_STATUS_FRAME_ID (0x502u)
#define CAN1_RES_STATUS_FRAME_ID (0x191u)
#define CAN1_RES_INITIALIZATION_FRAME_ID (0x711u)
#define CAN1_RES_NTM_NODE_CONTROL_FRAME_ID (0x00u)
#define CAN1_SWU_STATUS_FRAME_ID (0x38u)
#define CAN1_DBU_STATUS_1_FRAME_ID (0x40u)
#define CAN1_AMS_TEMPERATURES_FRAME_ID (0x23u)
#define CAN1_AMS_CELL_VOLTAGES_FRAME_ID (0x21u)
#define CAN1_AMS_CELL_TEMPERATURES_FRAME_ID (0x22u)
#define CAN1_ECU_STATUS_FRAME_ID (0x48u)
#define CAN1_EBS_STATUS_FRAME_ID (0x50u)
#define CAN1_DCU_PPS_FRAME_ID (0x10u)
#define CAN1_VMU_FL_FRAME_ID (0x30u)
#define CAN1_VMU_FR_FRAME_ID (0x31u)
#define CAN1_VMU_RL_FRAME_ID (0x32u)
#define CAN1_VMU_RR_FRAME_ID (0x33u)
#define CAN1_CCU_STATUS_2_FRAME_ID (0x59u)
#define CAN1_CCU_STATUS_1_FRAME_ID (0x58u)
#define CAN1_VEHICLE_STATUS_FRAME_ID (0x28u)
#define CAN1_FSE_ENERGY_METER_DATA_FRAME_ID (0x430u)
#define CAN1_FAULT_FRAME_ID (0xffu)
#define CAN1_DCU_STATUS_STEERING_BRAKE_FRAME_ID (0x11u)
#define CAN1_DBU_STATUS_2_FRAME_ID (0x41u)
#define CAN1_DV_CONTROL_TARGET_FRAME_ID (0x18u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_FRAME_ID (0x179u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_INFO_FRAME_ID (0x178u)
#define CAN1_SBG_ECAN_MSG_ODO_VEL_FRAME_ID (0x161u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_FRAME_ID (0x138u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_FRAME_ID (0x137u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_FRAME_ID (0x136u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_FRAME_ID (0x134u)
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_FRAME_ID (0x133u)
#define CAN1_SBG_ECAN_MSG_EKF_EULER_FRAME_ID (0x132u)
#define CAN1_SBG_ECAN_MSG_EKF_INFO_FRAME_ID (0x130u)
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_FRAME_ID (0x122u)
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_FRAME_ID (0x121u)
#define CAN1_SBG_ECAN_MSG_IMU_INFO_FRAME_ID (0x120u)
#define CAN1_SBG_ECAN_MSG_AUTO_SLIP_CURV_FRAME_ID (0x220u)
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_FRAME_ID (0x29u)

/* Frame lengths in bytes. */
#define CAN1_AMS_STATUS_1_LENGTH (8u)
#define CAN1_DV_DRIVING_DYNAMICS_1_LENGTH (8u)
#define CAN1_DV_DRIVING_DYNAMICS_2_LENGTH (8u)
#define CAN1_DV_SYSTEM_STATUS_LENGTH (8u)
#define CAN1_RES_STATUS_LENGTH (8u)
#define CAN1_RES_INITIALIZATION_LENGTH (8u)
#define CAN1_RES_NTM_NODE_CONTROL_LENGTH (8u)
#define CAN1_SWU_STATUS_LENGTH (8u)
#define CAN1_DBU_STATUS_1_LENGTH (8u)
#define CAN1_AMS_TEMPERATURES_LENGTH (6u)
#define CAN1_AMS_CELL_VOLTAGES_LENGTH (7u)
#define CAN1_AMS_CELL_TEMPERATURES_LENGTH (8u)
#define CAN1_ECU_STATUS_LENGTH (8u)
#define CAN1_EBS_STATUS_LENGTH (4u)
#define CAN1_DCU_PPS_LENGTH (8u)
#define CAN1_VMU_FL_LENGTH (6u)
#define CAN1_VMU_FR_LENGTH (6u)
#define CAN1_VMU_RL_LENGTH (6u)
#define CAN1_VMU_RR_LENGTH (6u)
#define CAN1_CCU_STATUS_2_LENGTH (8u)
#define CAN1_CCU_STATUS_1_LENGTH (8u)
#define CAN1_VEHICLE_STATUS_LENGTH (8u)
#define CAN1_FSE_ENERGY_METER_DATA_LENGTH (8u)
#define CAN1_FAULT_LENGTH (8u)
#define CAN1_DCU_STATUS_STEERING_BRAKE_LENGTH (8u)
#define CAN1_DBU_STATUS_2_LENGTH (8u)
#define CAN1_DV_CONTROL_TARGET_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_INFO_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_ODO_VEL_LENGTH (2u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_POS_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_EULER_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_EKF_INFO_LENGTH (4u)
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_LENGTH (6u)
#define CAN1_SBG_ECAN_MSG_IMU_INFO_LENGTH (8u)
#define CAN1_SBG_ECAN_MSG_AUTO_SLIP_CURV_LENGTH (7u)
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_LENGTH (8u)

/* Extended or standard frame types. */
#define CAN1_AMS_STATUS_1_IS_EXTENDED (0)
#define CAN1_DV_DRIVING_DYNAMICS_1_IS_EXTENDED (0)
#define CAN1_DV_DRIVING_DYNAMICS_2_IS_EXTENDED (0)
#define CAN1_DV_SYSTEM_STATUS_IS_EXTENDED (0)
#define CAN1_RES_STATUS_IS_EXTENDED (0)
#define CAN1_RES_INITIALIZATION_IS_EXTENDED (0)
#define CAN1_RES_NTM_NODE_CONTROL_IS_EXTENDED (0)
#define CAN1_SWU_STATUS_IS_EXTENDED (0)
#define CAN1_DBU_STATUS_1_IS_EXTENDED (0)
#define CAN1_AMS_TEMPERATURES_IS_EXTENDED (0)
#define CAN1_AMS_CELL_VOLTAGES_IS_EXTENDED (0)
#define CAN1_AMS_CELL_TEMPERATURES_IS_EXTENDED (0)
#define CAN1_ECU_STATUS_IS_EXTENDED (0)
#define CAN1_EBS_STATUS_IS_EXTENDED (0)
#define CAN1_DCU_PPS_IS_EXTENDED (0)
#define CAN1_VMU_FL_IS_EXTENDED (0)
#define CAN1_VMU_FR_IS_EXTENDED (0)
#define CAN1_VMU_RL_IS_EXTENDED (0)
#define CAN1_VMU_RR_IS_EXTENDED (0)
#define CAN1_CCU_STATUS_2_IS_EXTENDED (0)
#define CAN1_CCU_STATUS_1_IS_EXTENDED (0)
#define CAN1_VEHICLE_STATUS_IS_EXTENDED (0)
#define CAN1_FSE_ENERGY_METER_DATA_IS_EXTENDED (0)
#define CAN1_FAULT_IS_EXTENDED (0)
#define CAN1_DCU_STATUS_STEERING_BRAKE_IS_EXTENDED (0)
#define CAN1_DBU_STATUS_2_IS_EXTENDED (0)
#define CAN1_DV_CONTROL_TARGET_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_GPS1_HDT_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_ODO_VEL_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_VEL_NED_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_POS_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_POS_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_ORIENTATION_ACC_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_EULER_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_EKF_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_IMU_GYRO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_IMU_ACCEL_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_IMU_INFO_IS_EXTENDED (0)
#define CAN1_SBG_ECAN_MSG_AUTO_SLIP_CURV_IS_EXTENDED (0)
#define CAN1_VEHICLE_STATUS_WHEEL_SPEED_IS_EXTENDED (0)

/* Frame cycle times in milliseconds. */


/* Signal choices. */
#define CAN1_AMS_STATUS_1_CHARGING_STATUS_IDLE_CHOICE (0u)
#define CAN1_AMS_STATUS_1_CHARGING_STATUS_CHARGING_CHOICE (1u)
#define CAN1_AMS_STATUS_1_CHARGING_STATUS_DISCHARGING_CHOICE (2u)
#define CAN1_AMS_STATUS_1_CHARGING_STATUS_FULL_CHOICE (3u)

#define CAN1_AMS_STATUS_1_AIR1_CLOSED_OPEN_CHOICE (0u)
#define CAN1_AMS_STATUS_1_AIR1_CLOSED_CLOSED_CHOICE (1u)

#define CAN1_AMS_STATUS_1_AIR2_CLOSED_OPEN_CHOICE (0u)
#define CAN1_AMS_STATUS_1_AIR2_CLOSED_CLOSED_CHOICE (1u)

#define CAN1_AMS_STATUS_1_SC_CLOSED_OPEN_CHOICE (0u)
#define CAN1_AMS_STATUS_1_SC_CLOSED_CLOSED_CHOICE (1u)

#define CAN1_AMS_STATUS_1_PRE_CHARGE_STATUS_NOT_ACTIVE_CHOICE (0u)
#define CAN1_AMS_STATUS_1_PRE_CHARGE_STATUS_ACTIVE_CHOICE (1u)

#define CAN1_AMS_STATUS_1_AMS_ERROR_OK_CHOICE (0u)
#define CAN1_AMS_STATUS_1_AMS_ERROR_ERROR_CHOICE (1u)

#define CAN1_AMS_STATUS_1_IMD_ERROR_OK_CHOICE (0u)
#define CAN1_AMS_STATUS_1_IMD_ERROR_ERROR_CHOICE (1u)

#define CAN1_DV_SYSTEM_STATUS_AS_STATE_OFF_CHOICE (0u)
#define CAN1_DV_SYSTEM_STATUS_AS_STATE_READY_CHOICE (1u)
#define CAN1_DV_SYSTEM_STATUS_AS_STATE_DRIVING_CHOICE (2u)
#define CAN1_DV_SYSTEM_STATUS_AS_STATE_EMERGENCY_BRAKE_CHOICE (3u)
#define CAN1_DV_SYSTEM_STATUS_AS_STATE_FINISH_CHOICE (4u)

#define CAN1_DV_SYSTEM_STATUS_EBS_STATE_UNAVAILABLE_CHOICE (0u)
#define CAN1_DV_SYSTEM_STATUS_EBS_STATE_ARMED_CHOICE (1u)
#define CAN1_DV_SYSTEM_STATUS_EBS_STATE_ACTIVATED_CHOICE (2u)

#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_ACCELERATION_CHOICE (0u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_SKIDPAD_CHOICE (1u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_TRACKDRIVE_CHOICE (2u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_BRAKETEST_CHOICE (3u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_INSPECTION_CHOICE (4u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_AUTOCROSS_CHOICE (5u)
#define CAN1_DV_SYSTEM_STATUS_AMI_STATE_MANUAL_DRIVNING_CHOICE (6u)

#define CAN1_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_DISENGAGED_CHOICE (0u)
#define CAN1_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_ENGAGED_CHOICE (1u)
#define CAN1_DV_SYSTEM_STATUS_SERVICE_BRAKE_STATE_AVAILABLE_CHOICE (2u)

#define CAN1_RES_STATUS_E_STOP_E_STOP_OK_CHOICE (0u)
#define CAN1_RES_STATUS_E_STOP_E_STOP_ACTIVE_CHOICE (1u)

#define CAN1_RES_STATUS_SWITCH_STATUS_LOW_CHOICE (0u)
#define CAN1_RES_STATUS_SWITCH_STATUS_HIGH_CHOICE (1u)

#define CAN1_RES_STATUS_BUTTON_STATUS_LOW_CHOICE (0u)
#define CAN1_RES_STATUS_BUTTON_STATUS_HIGH_CHOICE (1u)

#define CAN1_RES_STATUS_E_STOP_REDUNDANCY_E_STOP_OK_CHOICE (0u)
#define CAN1_RES_STATUS_E_STOP_REDUNDANCY_E_STOP_ACTIVE_CHOICE (1u)

#define CAN1_VEHICLE_STATUS_CAR_STATE_CAR_OFF_CHOICE (0u)

/**
 * Signals in message ams_status_1.
 *
 * Used for DBU hardware IO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_status_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t charging_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t air1_closed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t air2_closed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sc_closed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pre_charge_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ams_error;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t imd_error;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t state_of_charge;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t min_cell_voltage;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t max_cell_voltage;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t min_cell_temperature;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t max_cell_temperature;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan_speed;
};

/**
 * Signals in message dv_driving_dynamics_1.
 *
 * Required by FSG.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_driving_dynamics_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t speed_target;

    /**
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steering_angle_actual;

    /**
     * Range: -
     * Scale: 0.5
     * Offset: 0
     */
    int8_t steering_angle_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydr_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_hydr_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_moment_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t motor_moment_target;
};

/**
 * Signals in message dv_driving_dynamics_2.
 *
 * Required by FSG.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_driving_dynamics_2_t {
    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int8_t acceleration_longitudinal;

    /**
     * Range: -
     * Scale: 0.001953125
     * Offset: 0
     */
    int8_t acceleration_lateral;

    /**
     * Range: -
     * Scale: 0.00195312
     * Offset: 0
     */
    int8_t yaw_rate;
};

/**
 * Signals in message dv_system_status.
 *
 * Required by FSG.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_system_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ami_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t service_brake_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t lap_counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t cones_count_actual;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint32_t cones_count_all;
};

/**
 * Signals in message res_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t e_stop;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t switch_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t e_stop_redundancy;
};

/**
 * Signals in message res_initialization.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_initialization_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t res_init;
};

/**
 * Signals in message res_ntm_node_control.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_res_ntm_node_control_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t requested_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t node_id;
};

/**
 * Signals in message swu_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_swu_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_5;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t button_6;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_switch_1;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_switch_2;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_switch_3;

    /**
     * Range: 0..7 (0..7 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotary_switch_4;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_1_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t encoder_2_button;

    /**
     * Range: -128..127 (-128..127 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t encoder_1;

    /**
     * Range: -128..127 (-128..127 -)
     * Scale: 1
     * Offset: 0
     */
    int8_t encoder_2;
};

/**
 * Signals in message dbu_status_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dbu_status_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t activate_ts_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ready_to_drive_button;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t dbu_temperature;
};

/**
 * Signals in message ams_temperatures.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_temperatures_t {
    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t pre_charge_resistor_temperature;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t fuse_resistor_temperature;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t aux_1_temperature;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t aux_2_temperature;
};

/**
 * Signals in message ams_cell_voltages.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_cell_voltages_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t voltage_multiplexor;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v1s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v7s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v2s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v8s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v3s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v9s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v4s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v10s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v11s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v5s12;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s1;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s2;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s3;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s4;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s5;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s6;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s7;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s8;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s9;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s10;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s11;

    /**
     * Range: 0..255.1020408163265306122448980 (2.5..4.5 V)
     * Scale: 0.00784
     * Offset: 2.5
     */
    uint8_t v6s12;
};

/**
 * Signals in message ams_cell_temperatures.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ams_cell_temperatures_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t temperature_multiplexor;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s1;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s2;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s3;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s4;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s5;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s6;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s7;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s8;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s9;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s10;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s11;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t1s12;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s1;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s2;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s3;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s4;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s5;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s6;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s7;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s8;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s9;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s10;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s11;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t2s12;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s1;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s2;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s3;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s4;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s5;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s6;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s7;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s8;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s9;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s10;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s11;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t3s12;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s1;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s2;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s3;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s4;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s5;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s6;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s7;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s8;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s9;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s10;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s11;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t4s12;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s1;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s2;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s3;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s4;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s5;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s6;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s7;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s8;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s9;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s10;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s11;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t t5s12;
};

/**
 * Signals in message ecu_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ecu_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t rst_button;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t close_airs;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_off;
};

/**
 * Signals in message ebs_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ebs_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sc_tsms_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t res_open;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ebs_pressure_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t ebs_pressure_2;
};

/**
 * Signals in message dcu_pps.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dcu_pps_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t apps_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bpps_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bpps_2;

    /**
     * Range: 0..51.2 (0..51.2 deg)
     * Scale: 1
     * Offset: 0
     */
    uint16_t acceleration_pedal_angle;

    /**
     * Range: 0..1.28 (0..12.8 deg)
     * Scale: 10
     * Offset: 0
     */
    uint8_t brake_pedal_angle;
};

/**
 * Signals in message vmu_fl.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vmu_fl_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t fl_load_cell;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t fl_suspention_potentiometer;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    uint16_t fl_temperature;
};

/**
 * Signals in message vmu_fr.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vmu_fr_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t fr_load_cell;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t fr_suspention_potentiometer;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    uint16_t fr_temperature;
};

/**
 * Signals in message vmu_rl.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vmu_rl_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t rl_load_cell;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t rl_suspention_potentiometer;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    uint16_t rl_temperature;
};

/**
 * Signals in message vmu_rr.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vmu_rr_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t rr_load_cell;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t rr_suspention_potentiometer;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    uint16_t rr_temperature;
};

/**
 * Signals in message ccu_status_2.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ccu_status_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t mux_id;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan1_speed;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan2_speed;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fan3_speed;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t fron_pump_speed;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t rear_pump_speed;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t inverter_pump_speed;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t fron_coolant_temperature;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t rear_coolant_temperature;

    /**
     * Range: 0..4095.004095004095004095004095 (-10..190 C)
     * Scale: 0.04884
     * Offset: -10
     */
    int16_t inverter_coolant_temperature;
};

/**
 * Signals in message ccu_status_1.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_ccu_status_1_t {
    /**
     * Range: -10..190 (-10..190 C)
     * Scale: 1
     * Offset: 0
     */
    uint8_t digital_input;

    /**
     * Range: -10..190 (-10..190 C)
     * Scale: 1
     * Offset: 0
     */
    uint8_t discharge_relay_open;

    /**
     * Range: -10..190 (-10..190 C)
     * Scale: 1
     * Offset: 0
     */
    uint16_t discharge_resistor_temperature;

    /**
     * Range: -10..190 (-10..190 C)
     * Scale: 1
     * Offset: 0
     */
    uint16_t extra_temperature;
};

/**
 * Signals in message vehicle_status.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vehicle_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t car_state;

    /**
     * Range: 0..200 (0..200 kph)
     * Scale: 1
     * Offset: 0
     */
    uint8_t car_velocity;

    /**
     * Range: 0..8000 (0..8000 W)
     * Scale: 1
     * Offset: 0
     */
    uint16_t car_power;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t car_regen_level;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ready_to_drive;
};

/**
 * Signals in message FSE_EnergyMeter_Data.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fse_energy_meter_data_t {
    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t msg_cntr;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t status;

    /**
     * Range: -32768..32767 (-98304..98301 W)
     * Scale: 3
     * Offset: 0
     */
    int16_t power;

    /**
     * Range: -32768..32767 (-1310.72..1310.68 V)
     * Scale: 0.04
     * Offset: 0
     */
    int16_t voltage;

    /**
     * Range: -32768..32767 (-1638.4..1638.35 A)
     * Scale: 0.05
     * Offset: 0
     */
    int16_t current;
};

/**
 * Signals in message fault.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_fault_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t unit_id;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_discrepancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t sc_open;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_off_watchdog_triggered;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bpps_discrepancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pressure_discrepancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_angle_discrepancy;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_out_of_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bpps_out_of_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_pressure_out_of_range;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_angle_out_of_range;
};

/**
 * Signals in message dcu_status_steering_brake.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dcu_status_steering_brake_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bspd_triggered;

    /**
     * Range: -10..190 (-10..190 C)
     * Scale: 1
     * Offset: 0
     */
    uint16_t dcu_temperature;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t steering_angle_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t steering_angle_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_pressure_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t brake_pressure_2;
};

/**
 * Signals in message dbu_status_2.
 *
 * Used for DBU software IO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dbu_status_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t screen_id;
};

/**
 * Signals in message dv_control_target.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_dv_control_target_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t dv_speed_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t dv_steering_angle_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t dv_brake_hydralic_target;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t dv_motor_moment_target;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_HDT.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_hdt_t {
    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t true_heading;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t true_heading_acc;

    /**
     * Range: -32768..32767 (-327.68..327.67 )
     * Scale: 0.01
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: 0..65535 (0..655.35 )
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t pitch_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_GPS1_HDT_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_gps1_hdt_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t status;
};

/**
 * Signals in message SBG_ECAN_MSG_ODO_VEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_odo_vel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_VEL_NED_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_vel_ned_acc_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_acc_d;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_vel_ned_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_n;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_e;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-1)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t velocity_d;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_POS_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_pos_acc_t {
    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t latitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t longitude_acc;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t altitude_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_POS.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_pos_t {
    /**
     * Range: -2147483648..2147483647 (-214.7483648..214.7483647 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t latitude;

    /**
     * Range: -2147483648..2147483647 (-214.7483648..214.7483647 )
     * Scale: 1e-07
     * Offset: 0
     */
    int32_t longitude;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_ORIENTATION_ACC.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_orientation_acc_t {
    /**
     * Range: 0..65535 (0..6.5535 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t roll_acc;

    /**
     * Range: 0..65535 (0..6.5535 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t pitch_acc;

    /**
     * Range: 0..65535 (0..6.5535 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    uint16_t yaw_acc;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_EULER.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_euler_t {
    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t roll;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t pitch;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t yaw;
};

/**
 * Signals in message SBG_ECAN_MSG_EKF_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_ekf_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_GYRO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_imu_gyro_t {
    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_x;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_y;

    /**
     * Range: -32768..32767 (-32.768..32.767 rad.s-1)
     * Scale: 0.001
     * Offset: 0
     */
    int16_t gyro_z;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_ACCEL.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_imu_accel_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_y;

    /**
     * Range: -32768..32767 (-327.68..327.67 m.s-2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t accel_z;
};

/**
 * Signals in message SBG_ECAN_MSG_IMU_INFO.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_imu_info_t {
    /**
     * Range: 0..2704 (0..2704 s)
     * Scale: 1
     * Offset: 0
     */
    uint32_t time_stamp;

    /**
     * Range: 0..65535 (0..65535 -)
     * Scale: 1
     * Offset: 0
     */
    uint16_t status;

    /**
     * Range: -32768..32767 (-327.68..327.67 C)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t temperature;
};

/**
 * Signals in message SBG_ECAN_MSG_AUTO_SLIP_CURV.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_sbg_ecan_msg_auto_slip_curv_t {
    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t angle_track;

    /**
     * Range: -32768..32767 (-3.2768..3.2767 rad)
     * Scale: 0.0001
     * Offset: 0
     */
    int16_t angle_slip;

    /**
     * Range: 0..65535 (0..655.35 m)
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t curvature_radius;

    /**
     * Range: 0..255 (0..255 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t auto_status;
};

/**
 * Signals in message vehicle_status_wheel_speed.
 *
 * All signal values are as on the CAN bus.
 */
struct can1_vehicle_status_wheel_speed_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t wheel_speed_fl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t wheel_speed_fr;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t wheel_speed_rl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t wheel_speed_rr;
};

/**
 * Pack message ams_status_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_status_1_pack(
    uint8_t *dst_p,
    const struct can1_ams_status_1_t *src_p,
    size_t size);

/**
 * Unpack message ams_status_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_status_1_unpack(
    struct can1_ams_status_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_charging_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_charging_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_charging_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_air1_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_air1_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_air1_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_air2_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_air2_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_air2_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_sc_closed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_sc_closed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_sc_closed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_pre_charge_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_pre_charge_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_pre_charge_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_ams_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_ams_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_ams_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_imd_error_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_imd_error_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_imd_error_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_state_of_charge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_state_of_charge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_state_of_charge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_min_cell_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_min_cell_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_min_cell_voltage_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_max_cell_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_max_cell_voltage_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_max_cell_voltage_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_status_1_min_cell_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_min_cell_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_min_cell_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_status_1_max_cell_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_max_cell_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_max_cell_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_status_1_fan_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_status_1_fan_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_status_1_fan_speed_is_in_range(uint8_t value);

/**
 * Pack message dv_driving_dynamics_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_driving_dynamics_1_pack(
    uint8_t *dst_p,
    const struct can1_dv_driving_dynamics_1_t *src_p,
    size_t size);

/**
 * Unpack message dv_driving_dynamics_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_driving_dynamics_1_unpack(
    struct can1_dv_driving_dynamics_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_driving_dynamics_1_speed_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_speed_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_speed_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_driving_dynamics_1_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_speed_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_speed_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_1_steering_angle_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_steering_angle_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_steering_angle_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_1_steering_angle_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_steering_angle_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_steering_angle_target_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_driving_dynamics_1_brake_hydr_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_brake_hydr_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_brake_hydr_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_driving_dynamics_1_brake_hydr_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_brake_hydr_target_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_brake_hydr_target_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_1_motor_moment_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_motor_moment_actual_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_motor_moment_actual_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_1_motor_moment_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_1_motor_moment_target_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_1_motor_moment_target_is_in_range(int8_t value);

/**
 * Pack message dv_driving_dynamics_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_driving_dynamics_2_pack(
    uint8_t *dst_p,
    const struct can1_dv_driving_dynamics_2_t *src_p,
    size_t size);

/**
 * Unpack message dv_driving_dynamics_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_driving_dynamics_2_unpack(
    struct can1_dv_driving_dynamics_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_2_acceleration_longitudinal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_2_acceleration_longitudinal_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_2_acceleration_longitudinal_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_2_acceleration_lateral_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_2_acceleration_lateral_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_2_acceleration_lateral_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_dv_driving_dynamics_2_yaw_rate_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_driving_dynamics_2_yaw_rate_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_driving_dynamics_2_yaw_rate_is_in_range(int8_t value);

/**
 * Pack message dv_system_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_system_status_pack(
    uint8_t *dst_p,
    const struct can1_dv_system_status_t *src_p,
    size_t size);

/**
 * Unpack message dv_system_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_system_status_unpack(
    struct can1_dv_system_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_as_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_as_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_as_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_ebs_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_ebs_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_ebs_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_ami_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_ami_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_ami_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_steering_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_steering_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_steering_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_service_brake_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_service_brake_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_service_brake_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_lap_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_lap_counter_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_lap_counter_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dv_system_status_cones_count_actual_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_cones_count_actual_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_cones_count_actual_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_dv_system_status_cones_count_all_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_system_status_cones_count_all_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_system_status_cones_count_all_is_in_range(uint32_t value);

/**
 * Pack message res_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_status_pack(
    uint8_t *dst_p,
    const struct can1_res_status_t *src_p,
    size_t size);

/**
 * Unpack message res_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_status_unpack(
    struct can1_res_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_e_stop_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_e_stop_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_e_stop_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_switch_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_switch_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_switch_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_button_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_button_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_button_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_status_e_stop_redundancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_status_e_stop_redundancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_status_e_stop_redundancy_is_in_range(uint8_t value);

/**
 * Pack message res_initialization.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_initialization_pack(
    uint8_t *dst_p,
    const struct can1_res_initialization_t *src_p,
    size_t size);

/**
 * Unpack message res_initialization.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_initialization_unpack(
    struct can1_res_initialization_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_initialization_res_init_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_initialization_res_init_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_initialization_res_init_is_in_range(uint8_t value);

/**
 * Pack message res_ntm_node_control.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_res_ntm_node_control_pack(
    uint8_t *dst_p,
    const struct can1_res_ntm_node_control_t *src_p,
    size_t size);

/**
 * Unpack message res_ntm_node_control.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_res_ntm_node_control_unpack(
    struct can1_res_ntm_node_control_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_ntm_node_control_requested_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_ntm_node_control_requested_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_ntm_node_control_requested_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_res_ntm_node_control_node_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_res_ntm_node_control_node_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_res_ntm_node_control_node_id_is_in_range(uint8_t value);

/**
 * Pack message swu_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_swu_status_pack(
    uint8_t *dst_p,
    const struct can1_swu_status_t *src_p,
    size_t size);

/**
 * Unpack message swu_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_swu_status_unpack(
    struct can1_swu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_button_6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_button_6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_button_6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_rotary_switch_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_rotary_switch_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_rotary_switch_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_rotary_switch_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_rotary_switch_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_rotary_switch_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_rotary_switch_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_rotary_switch_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_rotary_switch_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_rotary_switch_4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_rotary_switch_4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_rotary_switch_4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_encoder_1_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_encoder_1_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_encoder_1_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_swu_status_encoder_2_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_encoder_2_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_encoder_2_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_swu_status_encoder_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_encoder_1_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_encoder_1_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int8_t can1_swu_status_encoder_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_swu_status_encoder_2_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_swu_status_encoder_2_is_in_range(int8_t value);

/**
 * Pack message dbu_status_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dbu_status_1_pack(
    uint8_t *dst_p,
    const struct can1_dbu_status_1_t *src_p,
    size_t size);

/**
 * Unpack message dbu_status_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dbu_status_1_unpack(
    struct can1_dbu_status_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dbu_status_1_activate_ts_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_1_activate_ts_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_1_activate_ts_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dbu_status_1_ready_to_drive_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_1_ready_to_drive_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_1_ready_to_drive_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dbu_status_1_dbu_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_1_dbu_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_1_dbu_temperature_is_in_range(int16_t value);

/**
 * Pack message ams_temperatures.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_temperatures_pack(
    uint8_t *dst_p,
    const struct can1_ams_temperatures_t *src_p,
    size_t size);

/**
 * Unpack message ams_temperatures.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_temperatures_unpack(
    struct can1_ams_temperatures_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_temperatures_pre_charge_resistor_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_temperatures_pre_charge_resistor_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_temperatures_pre_charge_resistor_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_temperatures_fuse_resistor_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_temperatures_fuse_resistor_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_temperatures_fuse_resistor_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_temperatures_aux_1_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_temperatures_aux_1_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_temperatures_aux_1_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_temperatures_aux_2_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_temperatures_aux_2_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_temperatures_aux_2_temperature_is_in_range(int16_t value);

/**
 * Pack message ams_cell_voltages.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_cell_voltages_pack(
    uint8_t *dst_p,
    const struct can1_ams_cell_voltages_t *src_p,
    size_t size);

/**
 * Unpack message ams_cell_voltages.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_cell_voltages_unpack(
    struct can1_ams_cell_voltages_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_voltage_multiplexor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_voltage_multiplexor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_voltage_multiplexor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v1s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v1s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v1s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v7s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v7s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v7s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v2s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v2s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v2s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v8s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v8s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v8s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v3s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v3s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v3s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v9s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v9s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v9s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v4s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v4s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v4s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v10s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v10s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v10s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v11s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v11s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v11s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v5s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v5s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v5s12_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s4_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s4_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s5_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s5_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s6_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s6_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s7_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s7_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s8_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s8_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s9_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s9_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s10_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s10_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s11_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s11_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_voltages_v6s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_voltages_v6s12_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_voltages_v6s12_is_in_range(uint8_t value);

/**
 * Pack message ams_cell_temperatures.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ams_cell_temperatures_pack(
    uint8_t *dst_p,
    const struct can1_ams_cell_temperatures_t *src_p,
    size_t size);

/**
 * Unpack message ams_cell_temperatures.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ams_cell_temperatures_unpack(
    struct can1_ams_cell_temperatures_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ams_cell_temperatures_temperature_multiplexor_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_temperature_multiplexor_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_temperature_multiplexor_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t1s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t1s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t1s12_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t2s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t2s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t2s12_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t3s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t3s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t3s12_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t4s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t4s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t4s12_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s3_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s4_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s4_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s4_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s5_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s5_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s5_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s6_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s6_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s6_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s7_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s7_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s7_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s8_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s8_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s8_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s9_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s9_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s9_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s10_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s10_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s10_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s11_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s11_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s11_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ams_cell_temperatures_t5s12_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ams_cell_temperatures_t5s12_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ams_cell_temperatures_t5s12_is_in_range(int16_t value);

/**
 * Pack message ecu_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ecu_status_pack(
    uint8_t *dst_p,
    const struct can1_ecu_status_t *src_p,
    size_t size);

/**
 * Unpack message ecu_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ecu_status_unpack(
    struct can1_ecu_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ecu_status_rst_button_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ecu_status_rst_button_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ecu_status_rst_button_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ecu_status_close_airs_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ecu_status_close_airs_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ecu_status_close_airs_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ecu_status_ts_off_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ecu_status_ts_off_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ecu_status_ts_off_is_in_range(uint8_t value);

/**
 * Pack message ebs_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ebs_status_pack(
    uint8_t *dst_p,
    const struct can1_ebs_status_t *src_p,
    size_t size);

/**
 * Unpack message ebs_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ebs_status_unpack(
    struct can1_ebs_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ebs_status_sc_tsms_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_sc_tsms_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_sc_tsms_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ebs_status_res_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_res_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_res_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ebs_status_ebs_pressure_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_ebs_pressure_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_ebs_pressure_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ebs_status_ebs_pressure_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ebs_status_ebs_pressure_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ebs_status_ebs_pressure_2_is_in_range(uint16_t value);

/**
 * Pack message dcu_pps.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dcu_pps_pack(
    uint8_t *dst_p,
    const struct can1_dcu_pps_t *src_p,
    size_t size);

/**
 * Unpack message dcu_pps.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dcu_pps_unpack(
    struct can1_dcu_pps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_pps_apps_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_pps_apps_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_pps_apps_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_pps_apps_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_pps_apps_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_pps_apps_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_pps_bpps_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_pps_bpps_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_pps_bpps_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_pps_bpps_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_pps_bpps_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_pps_bpps_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_pps_acceleration_pedal_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_pps_acceleration_pedal_angle_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_pps_acceleration_pedal_angle_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dcu_pps_brake_pedal_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_pps_brake_pedal_angle_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_pps_brake_pedal_angle_is_in_range(uint8_t value);

/**
 * Pack message vmu_fl.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vmu_fl_pack(
    uint8_t *dst_p,
    const struct can1_vmu_fl_t *src_p,
    size_t size);

/**
 * Unpack message vmu_fl.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vmu_fl_unpack(
    struct can1_vmu_fl_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vmu_fl_fl_load_cell_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_fl_fl_load_cell_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_fl_fl_load_cell_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vmu_fl_fl_suspention_potentiometer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_fl_fl_suspention_potentiometer_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_fl_fl_suspention_potentiometer_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_vmu_fl_fl_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_fl_fl_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_fl_fl_temperature_is_in_range(uint16_t value);

/**
 * Pack message vmu_fr.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vmu_fr_pack(
    uint8_t *dst_p,
    const struct can1_vmu_fr_t *src_p,
    size_t size);

/**
 * Unpack message vmu_fr.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vmu_fr_unpack(
    struct can1_vmu_fr_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vmu_fr_fr_load_cell_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_fr_fr_load_cell_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_fr_fr_load_cell_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vmu_fr_fr_suspention_potentiometer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_fr_fr_suspention_potentiometer_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_fr_fr_suspention_potentiometer_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_vmu_fr_fr_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_fr_fr_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_fr_fr_temperature_is_in_range(uint16_t value);

/**
 * Pack message vmu_rl.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vmu_rl_pack(
    uint8_t *dst_p,
    const struct can1_vmu_rl_t *src_p,
    size_t size);

/**
 * Unpack message vmu_rl.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vmu_rl_unpack(
    struct can1_vmu_rl_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vmu_rl_rl_load_cell_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_rl_rl_load_cell_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_rl_rl_load_cell_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vmu_rl_rl_suspention_potentiometer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_rl_rl_suspention_potentiometer_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_rl_rl_suspention_potentiometer_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_vmu_rl_rl_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_rl_rl_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_rl_rl_temperature_is_in_range(uint16_t value);

/**
 * Pack message vmu_rr.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vmu_rr_pack(
    uint8_t *dst_p,
    const struct can1_vmu_rr_t *src_p,
    size_t size);

/**
 * Unpack message vmu_rr.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vmu_rr_unpack(
    struct can1_vmu_rr_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vmu_rr_rr_load_cell_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_rr_rr_load_cell_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_rr_rr_load_cell_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vmu_rr_rr_suspention_potentiometer_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_rr_rr_suspention_potentiometer_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_rr_rr_suspention_potentiometer_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_vmu_rr_rr_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vmu_rr_rr_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vmu_rr_rr_temperature_is_in_range(uint16_t value);

/**
 * Pack message ccu_status_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ccu_status_2_pack(
    uint8_t *dst_p,
    const struct can1_ccu_status_2_t *src_p,
    size_t size);

/**
 * Unpack message ccu_status_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ccu_status_2_unpack(
    struct can1_ccu_status_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_2_mux_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_mux_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_mux_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_2_fan1_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_fan1_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_fan1_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_2_fan2_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_fan2_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_fan2_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_2_fan3_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_fan3_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_fan3_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_2_fron_pump_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_fron_pump_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_fron_pump_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_2_rear_pump_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_rear_pump_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_rear_pump_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_2_inverter_pump_speed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_inverter_pump_speed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_inverter_pump_speed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ccu_status_2_fron_coolant_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_fron_coolant_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_fron_coolant_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ccu_status_2_rear_coolant_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_rear_coolant_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_rear_coolant_temperature_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_ccu_status_2_inverter_coolant_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_2_inverter_coolant_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_2_inverter_coolant_temperature_is_in_range(int16_t value);

/**
 * Pack message ccu_status_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_ccu_status_1_pack(
    uint8_t *dst_p,
    const struct can1_ccu_status_1_t *src_p,
    size_t size);

/**
 * Unpack message ccu_status_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_ccu_status_1_unpack(
    struct can1_ccu_status_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_digital_input_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_digital_input_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_digital_input_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_ccu_status_1_discharge_relay_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_discharge_relay_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_discharge_relay_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ccu_status_1_discharge_resistor_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_discharge_resistor_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_discharge_resistor_temperature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_ccu_status_1_extra_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_ccu_status_1_extra_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_ccu_status_1_extra_temperature_is_in_range(uint16_t value);

/**
 * Pack message vehicle_status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vehicle_status_pack(
    uint8_t *dst_p,
    const struct can1_vehicle_status_t *src_p,
    size_t size);

/**
 * Unpack message vehicle_status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vehicle_status_unpack(
    struct can1_vehicle_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_car_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_car_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_car_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_car_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_car_velocity_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_car_velocity_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_vehicle_status_car_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_car_power_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_car_power_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_car_regen_level_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_car_regen_level_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_car_regen_level_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_vehicle_status_ready_to_drive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_ready_to_drive_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_ready_to_drive_is_in_range(uint8_t value);

/**
 * Pack message FSE_EnergyMeter_Data.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fse_energy_meter_data_pack(
    uint8_t *dst_p,
    const struct can1_fse_energy_meter_data_t *src_p,
    size_t size);

/**
 * Unpack message FSE_EnergyMeter_Data.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fse_energy_meter_data_unpack(
    struct can1_fse_energy_meter_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fse_energy_meter_data_msg_cntr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fse_energy_meter_data_msg_cntr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fse_energy_meter_data_msg_cntr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fse_energy_meter_data_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fse_energy_meter_data_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fse_energy_meter_data_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_fse_energy_meter_data_power_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fse_energy_meter_data_power_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fse_energy_meter_data_power_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_fse_energy_meter_data_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fse_energy_meter_data_voltage_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fse_energy_meter_data_voltage_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_fse_energy_meter_data_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fse_energy_meter_data_current_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fse_energy_meter_data_current_is_in_range(int16_t value);

/**
 * Pack message fault.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_fault_pack(
    uint8_t *dst_p,
    const struct can1_fault_t *src_p,
    size_t size);

/**
 * Unpack message fault.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_fault_unpack(
    struct can1_fault_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_unit_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_unit_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_unit_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_apps_discrepancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_apps_discrepancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_apps_discrepancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_sc_open_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_sc_open_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_sc_open_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_ts_off_watchdog_triggered_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_ts_off_watchdog_triggered_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_ts_off_watchdog_triggered_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_bpps_discrepancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_bpps_discrepancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_bpps_discrepancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_brake_pressure_discrepancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_brake_pressure_discrepancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_brake_pressure_discrepancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_steering_angle_discrepancy_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_steering_angle_discrepancy_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_steering_angle_discrepancy_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_apps_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_apps_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_apps_out_of_range_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_bpps_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_bpps_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_bpps_out_of_range_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_brake_pressure_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_brake_pressure_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_brake_pressure_out_of_range_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_fault_steering_angle_out_of_range_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_fault_steering_angle_out_of_range_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_fault_steering_angle_out_of_range_is_in_range(uint8_t value);

/**
 * Pack message dcu_status_steering_brake.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dcu_status_steering_brake_pack(
    uint8_t *dst_p,
    const struct can1_dcu_status_steering_brake_t *src_p,
    size_t size);

/**
 * Unpack message dcu_status_steering_brake.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dcu_status_steering_brake_unpack(
    struct can1_dcu_status_steering_brake_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dcu_status_steering_brake_bspd_triggered_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_steering_brake_bspd_triggered_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_steering_brake_bspd_triggered_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_status_steering_brake_dcu_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_steering_brake_dcu_temperature_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_steering_brake_dcu_temperature_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dcu_status_steering_brake_steering_angle_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_steering_brake_steering_angle_1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_steering_brake_steering_angle_1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_dcu_status_steering_brake_steering_angle_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_steering_brake_steering_angle_2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_steering_brake_steering_angle_2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_status_steering_brake_brake_pressure_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_steering_brake_brake_pressure_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_steering_brake_brake_pressure_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dcu_status_steering_brake_brake_pressure_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dcu_status_steering_brake_brake_pressure_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dcu_status_steering_brake_brake_pressure_2_is_in_range(uint16_t value);

/**
 * Pack message dbu_status_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dbu_status_2_pack(
    uint8_t *dst_p,
    const struct can1_dbu_status_2_t *src_p,
    size_t size);

/**
 * Unpack message dbu_status_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dbu_status_2_unpack(
    struct can1_dbu_status_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_dbu_status_2_screen_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dbu_status_2_screen_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dbu_status_2_screen_id_is_in_range(uint8_t value);

/**
 * Pack message dv_control_target.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_dv_control_target_pack(
    uint8_t *dst_p,
    const struct can1_dv_control_target_t *src_p,
    size_t size);

/**
 * Unpack message dv_control_target.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_dv_control_target_unpack(
    struct can1_dv_control_target_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dv_control_target_dv_speed_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_speed_target_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_speed_target_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dv_control_target_dv_steering_angle_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_steering_angle_target_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_steering_angle_target_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dv_control_target_dv_brake_hydralic_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_brake_hydralic_target_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_brake_hydralic_target_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_dv_control_target_dv_motor_moment_target_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_dv_control_target_dv_motor_moment_target_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_dv_control_target_dv_motor_moment_target_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_HDT.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_hdt_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_hdt_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_HDT.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_hdt_unpack(
    struct can1_sbg_ecan_msg_gps1_hdt_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_hdt_true_heading_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_true_heading_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_true_heading_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_hdt_true_heading_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_true_heading_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_true_heading_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_gps1_hdt_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_hdt_pitch_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_pitch_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_pitch_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_GPS1_HDT_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_gps1_hdt_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_gps1_hdt_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_GPS1_HDT_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_gps1_hdt_info_unpack(
    struct can1_sbg_ecan_msg_gps1_hdt_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_gps1_hdt_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_gps1_hdt_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_gps1_hdt_info_status_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_gps1_hdt_info_status_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_ODO_VEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_odo_vel_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_odo_vel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_ODO_VEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_odo_vel_unpack(
    struct can1_sbg_ecan_msg_odo_vel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_odo_vel_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_odo_vel_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_odo_vel_velocity_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_VEL_NED_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_vel_ned_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_VEL_NED_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_acc_unpack(
    struct can1_sbg_ecan_msg_ekf_vel_ned_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_acc_velocity_acc_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_vel_ned_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_VEL_NED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_vel_ned_unpack(
    struct can1_sbg_ecan_msg_ekf_vel_ned_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_velocity_n_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_velocity_n_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_velocity_n_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_velocity_e_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_velocity_e_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_velocity_e_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_vel_ned_velocity_d_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_vel_ned_velocity_d_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_vel_ned_velocity_d_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_POS_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_pos_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_pos_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_POS_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_pos_acc_unpack(
    struct can1_sbg_ecan_msg_ekf_pos_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_pos_acc_latitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_acc_latitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_acc_latitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_pos_acc_longitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_acc_longitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_acc_longitude_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_pos_acc_altitude_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_acc_altitude_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_acc_altitude_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_POS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_pos_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_pos_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_POS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_pos_unpack(
    struct can1_sbg_ecan_msg_ekf_pos_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_ekf_pos_latitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_latitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_latitude_is_in_range(int32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int32_t can1_sbg_ecan_msg_ekf_pos_longitude_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_pos_longitude_decode(int32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_pos_longitude_is_in_range(int32_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_ORIENTATION_ACC.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_orientation_acc_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_orientation_acc_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_ORIENTATION_ACC.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_orientation_acc_unpack(
    struct can1_sbg_ecan_msg_ekf_orientation_acc_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_orientation_acc_roll_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_orientation_acc_roll_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_orientation_acc_roll_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_orientation_acc_pitch_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_orientation_acc_pitch_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_orientation_acc_pitch_acc_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_ekf_orientation_acc_yaw_acc_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_orientation_acc_yaw_acc_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_orientation_acc_yaw_acc_is_in_range(uint16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_EULER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_euler_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_euler_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_EULER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_euler_unpack(
    struct can1_sbg_ecan_msg_ekf_euler_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_euler_roll_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_euler_roll_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_euler_roll_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_euler_pitch_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_euler_pitch_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_euler_pitch_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_ekf_euler_yaw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_euler_yaw_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_euler_yaw_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_EKF_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_ekf_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_ekf_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_EKF_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_ekf_info_unpack(
    struct can1_sbg_ecan_msg_ekf_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_ekf_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_ekf_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_ekf_info_time_stamp_is_in_range(uint32_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_GYRO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_imu_gyro_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_imu_gyro_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_GYRO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_imu_gyro_unpack(
    struct can1_sbg_ecan_msg_imu_gyro_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_gyro_gyro_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_gyro_gyro_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_gyro_gyro_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_gyro_gyro_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_gyro_gyro_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_gyro_gyro_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_gyro_gyro_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_gyro_gyro_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_gyro_gyro_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_ACCEL.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_imu_accel_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_imu_accel_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_ACCEL.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_imu_accel_unpack(
    struct can1_sbg_ecan_msg_imu_accel_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_accel_accel_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_accel_accel_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_accel_accel_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_accel_accel_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_accel_accel_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_accel_accel_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_accel_accel_z_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_accel_accel_z_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_accel_accel_z_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_IMU_INFO.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_imu_info_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_imu_info_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_IMU_INFO.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_imu_info_unpack(
    struct can1_sbg_ecan_msg_imu_info_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint32_t can1_sbg_ecan_msg_imu_info_time_stamp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_info_time_stamp_decode(uint32_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_info_time_stamp_is_in_range(uint32_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_imu_info_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_info_status_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_info_status_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_imu_info_temperature_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_imu_info_temperature_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_imu_info_temperature_is_in_range(int16_t value);

/**
 * Pack message SBG_ECAN_MSG_AUTO_SLIP_CURV.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_sbg_ecan_msg_auto_slip_curv_pack(
    uint8_t *dst_p,
    const struct can1_sbg_ecan_msg_auto_slip_curv_t *src_p,
    size_t size);

/**
 * Unpack message SBG_ECAN_MSG_AUTO_SLIP_CURV.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_sbg_ecan_msg_auto_slip_curv_unpack(
    struct can1_sbg_ecan_msg_auto_slip_curv_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_auto_slip_curv_angle_track_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_auto_slip_curv_angle_track_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_auto_slip_curv_angle_track_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_sbg_ecan_msg_auto_slip_curv_angle_slip_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_auto_slip_curv_angle_slip_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_auto_slip_curv_angle_slip_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint16_t can1_sbg_ecan_msg_auto_slip_curv_curvature_radius_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_auto_slip_curv_curvature_radius_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_auto_slip_curv_curvature_radius_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
uint8_t can1_sbg_ecan_msg_auto_slip_curv_auto_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_sbg_ecan_msg_auto_slip_curv_auto_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_sbg_ecan_msg_auto_slip_curv_auto_status_is_in_range(uint8_t value);

/**
 * Pack message vehicle_status_wheel_speed.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int can1_vehicle_status_wheel_speed_pack(
    uint8_t *dst_p,
    const struct can1_vehicle_status_wheel_speed_t *src_p,
    size_t size);

/**
 * Unpack message vehicle_status_wheel_speed.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int can1_vehicle_status_wheel_speed_unpack(
    struct can1_vehicle_status_wheel_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_speed_wheel_speed_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_speed_wheel_speed_fl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_speed_wheel_speed_fl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_speed_wheel_speed_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_speed_wheel_speed_fr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_speed_wheel_speed_fr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_speed_wheel_speed_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_speed_wheel_speed_rl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_speed_wheel_speed_rl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
int16_t can1_vehicle_status_wheel_speed_wheel_speed_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double can1_vehicle_status_wheel_speed_wheel_speed_rr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool can1_vehicle_status_wheel_speed_wheel_speed_rr_is_in_range(int16_t value);


#ifdef __cplusplus
}
#endif

#endif
