/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 37.0.7 Mon Apr  4 17:52:22 2022.
 */

#include <string.h>

#include "can2.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u64(
    uint64_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u64(
    uint64_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint64_t unpack_left_shift_u64(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint64_t)((uint64_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint64_t unpack_right_shift_u64(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint64_t)((uint64_t)(value & mask) >> shift);
}

int can2_amk1_actual_values_1_pack(
    uint8_t *dst_p,
    const struct can2_amk1_actual_values_1_t *src_p,
    size_t size)
{
    uint16_t amk1_actual_velocity;
    uint16_t amk1_magnetizing_current;
    uint16_t amk1_torque_current;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[1] |= pack_left_shift_u8(src_p->amk1_status_system_ready, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk1_status_error, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk1_status_warning, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk1_status_quit_dc_on, 3u, 0x08u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk1_status_dc_on, 4u, 0x10u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk1_status_quit_inverter_on, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk1_status_inverter_on, 6u, 0x40u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk1_derating, 7u, 0x80u);
    amk1_actual_velocity = (uint16_t)src_p->amk1_actual_velocity;
    dst_p[2] |= pack_left_shift_u16(amk1_actual_velocity, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(amk1_actual_velocity, 8u, 0xffu);
    amk1_torque_current = (uint16_t)src_p->amk1_torque_current;
    dst_p[4] |= pack_left_shift_u16(amk1_torque_current, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(amk1_torque_current, 8u, 0xffu);
    amk1_magnetizing_current = (uint16_t)src_p->amk1_magnetizing_current;
    dst_p[6] |= pack_left_shift_u16(amk1_magnetizing_current, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(amk1_magnetizing_current, 8u, 0xffu);

    return (8);
}

int can2_amk1_actual_values_1_unpack(
    struct can2_amk1_actual_values_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t amk1_actual_velocity;
    uint16_t amk1_magnetizing_current;
    uint16_t amk1_torque_current;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->amk1_status_system_ready = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->amk1_status_error = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->amk1_status_warning = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->amk1_status_quit_dc_on = unpack_right_shift_u8(src_p[1], 3u, 0x08u);
    dst_p->amk1_status_dc_on = unpack_right_shift_u8(src_p[1], 4u, 0x10u);
    dst_p->amk1_status_quit_inverter_on = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    dst_p->amk1_status_inverter_on = unpack_right_shift_u8(src_p[1], 6u, 0x40u);
    dst_p->amk1_derating = unpack_right_shift_u8(src_p[1], 7u, 0x80u);
    amk1_actual_velocity = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    amk1_actual_velocity |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->amk1_actual_velocity = (int16_t)amk1_actual_velocity;
    amk1_torque_current = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    amk1_torque_current |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->amk1_torque_current = (int16_t)amk1_torque_current;
    amk1_magnetizing_current = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    amk1_magnetizing_current |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->amk1_magnetizing_current = (int16_t)amk1_magnetizing_current;

    return (0);
}

uint8_t can2_amk1_actual_values_1_amk1_status_system_ready_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk1_actual_values_1_amk1_status_system_ready_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk1_actual_values_1_amk1_status_system_ready_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk1_actual_values_1_amk1_status_error_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk1_actual_values_1_amk1_status_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk1_actual_values_1_amk1_status_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk1_actual_values_1_amk1_status_warning_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk1_actual_values_1_amk1_status_warning_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk1_actual_values_1_amk1_status_warning_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk1_actual_values_1_amk1_status_quit_dc_on_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk1_actual_values_1_amk1_status_quit_dc_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk1_actual_values_1_amk1_status_quit_dc_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk1_actual_values_1_amk1_status_dc_on_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk1_actual_values_1_amk1_status_dc_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk1_actual_values_1_amk1_status_dc_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk1_actual_values_1_amk1_status_quit_inverter_on_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk1_actual_values_1_amk1_status_quit_inverter_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk1_actual_values_1_amk1_status_quit_inverter_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk1_actual_values_1_amk1_status_inverter_on_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk1_actual_values_1_amk1_status_inverter_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk1_actual_values_1_amk1_status_inverter_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk1_actual_values_1_amk1_derating_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk1_actual_values_1_amk1_derating_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk1_actual_values_1_amk1_derating_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int16_t can2_amk1_actual_values_1_amk1_actual_velocity_encode(double value)
{
    return (int16_t)(value);
}

double can2_amk1_actual_values_1_amk1_actual_velocity_decode(int16_t value)
{
    return ((double)value);
}

bool can2_amk1_actual_values_1_amk1_actual_velocity_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can2_amk1_actual_values_1_amk1_torque_current_encode(double value)
{
    return (int16_t)(value);
}

double can2_amk1_actual_values_1_amk1_torque_current_decode(int16_t value)
{
    return ((double)value);
}

bool can2_amk1_actual_values_1_amk1_torque_current_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can2_amk1_actual_values_1_amk1_magnetizing_current_encode(double value)
{
    return (int16_t)(value);
}

double can2_amk1_actual_values_1_amk1_magnetizing_current_decode(int16_t value)
{
    return ((double)value);
}

bool can2_amk1_actual_values_1_amk1_magnetizing_current_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can2_amk1_actual_values_2_pack(
    uint8_t *dst_p,
    const struct can2_amk1_actual_values_2_t *src_p,
    size_t size)
{
    uint16_t amk1_temp_igbt;
    uint16_t amk1_temp_inverter;
    uint16_t amk1_temp_motor;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    amk1_temp_motor = (uint16_t)src_p->amk1_temp_motor;
    dst_p[0] |= pack_left_shift_u16(amk1_temp_motor, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(amk1_temp_motor, 8u, 0xffu);
    amk1_temp_inverter = (uint16_t)src_p->amk1_temp_inverter;
    dst_p[2] |= pack_left_shift_u16(amk1_temp_inverter, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(amk1_temp_inverter, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->amk1_error_info, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->amk1_error_info, 8u, 0xffu);
    amk1_temp_igbt = (uint16_t)src_p->amk1_temp_igbt;
    dst_p[6] |= pack_left_shift_u16(amk1_temp_igbt, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(amk1_temp_igbt, 8u, 0xffu);

    return (8);
}

int can2_amk1_actual_values_2_unpack(
    struct can2_amk1_actual_values_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t amk1_temp_igbt;
    uint16_t amk1_temp_inverter;
    uint16_t amk1_temp_motor;

    if (size < 8u) {
        return (-EINVAL);
    }

    amk1_temp_motor = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    amk1_temp_motor |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->amk1_temp_motor = (int16_t)amk1_temp_motor;
    amk1_temp_inverter = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    amk1_temp_inverter |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->amk1_temp_inverter = (int16_t)amk1_temp_inverter;
    dst_p->amk1_error_info = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->amk1_error_info |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    amk1_temp_igbt = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    amk1_temp_igbt |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->amk1_temp_igbt = (int16_t)amk1_temp_igbt;

    return (0);
}

int16_t can2_amk1_actual_values_2_amk1_temp_motor_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can2_amk1_actual_values_2_amk1_temp_motor_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can2_amk1_actual_values_2_amk1_temp_motor_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can2_amk1_actual_values_2_amk1_temp_inverter_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can2_amk1_actual_values_2_amk1_temp_inverter_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can2_amk1_actual_values_2_amk1_temp_inverter_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint16_t can2_amk1_actual_values_2_amk1_error_info_encode(double value)
{
    return (uint16_t)(value);
}

double can2_amk1_actual_values_2_amk1_error_info_decode(uint16_t value)
{
    return ((double)value);
}

bool can2_amk1_actual_values_2_amk1_error_info_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int16_t can2_amk1_actual_values_2_amk1_temp_igbt_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can2_amk1_actual_values_2_amk1_temp_igbt_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can2_amk1_actual_values_2_amk1_temp_igbt_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can2_amk1_setpoints_1_pack(
    uint8_t *dst_p,
    const struct can2_amk1_setpoints_1_t *src_p,
    size_t size)
{
    uint16_t amk1_target_velocity;
    uint16_t amk1_torque_limit_negativ;
    uint16_t amk1_torque_limit_positiv;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[1] |= pack_left_shift_u8(src_p->amk1_control_inverter_on, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk1_control_dc_on, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk1_control_enable, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk1_control_error_reset, 3u, 0x08u);
    amk1_target_velocity = (uint16_t)src_p->amk1_target_velocity;
    dst_p[2] |= pack_left_shift_u16(amk1_target_velocity, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(amk1_target_velocity, 8u, 0xffu);
    amk1_torque_limit_positiv = (uint16_t)src_p->amk1_torque_limit_positiv;
    dst_p[4] |= pack_left_shift_u16(amk1_torque_limit_positiv, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(amk1_torque_limit_positiv, 8u, 0xffu);
    amk1_torque_limit_negativ = (uint16_t)src_p->amk1_torque_limit_negativ;
    dst_p[6] |= pack_left_shift_u16(amk1_torque_limit_negativ, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(amk1_torque_limit_negativ, 8u, 0xffu);

    return (8);
}

int can2_amk1_setpoints_1_unpack(
    struct can2_amk1_setpoints_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t amk1_target_velocity;
    uint16_t amk1_torque_limit_negativ;
    uint16_t amk1_torque_limit_positiv;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->amk1_control_inverter_on = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->amk1_control_dc_on = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->amk1_control_enable = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->amk1_control_error_reset = unpack_right_shift_u8(src_p[1], 3u, 0x08u);
    amk1_target_velocity = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    amk1_target_velocity |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->amk1_target_velocity = (int16_t)amk1_target_velocity;
    amk1_torque_limit_positiv = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    amk1_torque_limit_positiv |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->amk1_torque_limit_positiv = (int16_t)amk1_torque_limit_positiv;
    amk1_torque_limit_negativ = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    amk1_torque_limit_negativ |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->amk1_torque_limit_negativ = (int16_t)amk1_torque_limit_negativ;

    return (0);
}

uint8_t can2_amk1_setpoints_1_amk1_control_inverter_on_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk1_setpoints_1_amk1_control_inverter_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk1_setpoints_1_amk1_control_inverter_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk1_setpoints_1_amk1_control_dc_on_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk1_setpoints_1_amk1_control_dc_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk1_setpoints_1_amk1_control_dc_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk1_setpoints_1_amk1_control_enable_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk1_setpoints_1_amk1_control_enable_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk1_setpoints_1_amk1_control_enable_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk1_setpoints_1_amk1_control_error_reset_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk1_setpoints_1_amk1_control_error_reset_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk1_setpoints_1_amk1_control_error_reset_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int16_t can2_amk1_setpoints_1_amk1_target_velocity_encode(double value)
{
    return (int16_t)(value);
}

double can2_amk1_setpoints_1_amk1_target_velocity_decode(int16_t value)
{
    return ((double)value);
}

bool can2_amk1_setpoints_1_amk1_target_velocity_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can2_amk1_setpoints_1_amk1_torque_limit_positiv_encode(double value)
{
    return (int16_t)(value);
}

double can2_amk1_setpoints_1_amk1_torque_limit_positiv_decode(int16_t value)
{
    return ((double)value);
}

bool can2_amk1_setpoints_1_amk1_torque_limit_positiv_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can2_amk1_setpoints_1_amk1_torque_limit_negativ_encode(double value)
{
    return (int16_t)(value);
}

double can2_amk1_setpoints_1_amk1_torque_limit_negativ_decode(int16_t value)
{
    return ((double)value);
}

bool can2_amk1_setpoints_1_amk1_torque_limit_negativ_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can2_amk2_actual_values_1_pack(
    uint8_t *dst_p,
    const struct can2_amk2_actual_values_1_t *src_p,
    size_t size)
{
    uint16_t amk2_actual_velocity;
    uint16_t amk2_magnetizing_current;
    uint16_t amk2_torque_current;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[1] |= pack_left_shift_u8(src_p->amk2_system_ready, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk2_error, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk2_warning, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk2_status_quit_dc_on, 3u, 0x08u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk2_status_dc_on, 4u, 0x10u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk2_status_quit_inverter_on, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk2_status_inverter_on, 6u, 0x40u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk2_status_derating, 7u, 0x80u);
    amk2_actual_velocity = (uint16_t)src_p->amk2_actual_velocity;
    dst_p[2] |= pack_left_shift_u16(amk2_actual_velocity, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(amk2_actual_velocity, 8u, 0xffu);
    amk2_torque_current = (uint16_t)src_p->amk2_torque_current;
    dst_p[4] |= pack_left_shift_u16(amk2_torque_current, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(amk2_torque_current, 8u, 0xffu);
    amk2_magnetizing_current = (uint16_t)src_p->amk2_magnetizing_current;
    dst_p[6] |= pack_left_shift_u16(amk2_magnetizing_current, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(amk2_magnetizing_current, 8u, 0xffu);

    return (8);
}

int can2_amk2_actual_values_1_unpack(
    struct can2_amk2_actual_values_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t amk2_actual_velocity;
    uint16_t amk2_magnetizing_current;
    uint16_t amk2_torque_current;

    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->amk2_system_ready = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->amk2_error = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->amk2_warning = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->amk2_status_quit_dc_on = unpack_right_shift_u8(src_p[1], 3u, 0x08u);
    dst_p->amk2_status_dc_on = unpack_right_shift_u8(src_p[1], 4u, 0x10u);
    dst_p->amk2_status_quit_inverter_on = unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    dst_p->amk2_status_inverter_on = unpack_right_shift_u8(src_p[1], 6u, 0x40u);
    dst_p->amk2_status_derating = unpack_right_shift_u8(src_p[1], 7u, 0x80u);
    amk2_actual_velocity = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    amk2_actual_velocity |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->amk2_actual_velocity = (int16_t)amk2_actual_velocity;
    amk2_torque_current = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    amk2_torque_current |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->amk2_torque_current = (int16_t)amk2_torque_current;
    amk2_magnetizing_current = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    amk2_magnetizing_current |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->amk2_magnetizing_current = (int16_t)amk2_magnetizing_current;

    return (0);
}

uint8_t can2_amk2_actual_values_1_amk2_system_ready_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk2_actual_values_1_amk2_system_ready_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk2_actual_values_1_amk2_system_ready_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk2_actual_values_1_amk2_error_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk2_actual_values_1_amk2_error_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk2_actual_values_1_amk2_error_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk2_actual_values_1_amk2_warning_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk2_actual_values_1_amk2_warning_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk2_actual_values_1_amk2_warning_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk2_actual_values_1_amk2_status_quit_dc_on_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk2_actual_values_1_amk2_status_quit_dc_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk2_actual_values_1_amk2_status_quit_dc_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk2_actual_values_1_amk2_status_dc_on_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk2_actual_values_1_amk2_status_dc_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk2_actual_values_1_amk2_status_dc_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk2_actual_values_1_amk2_status_quit_inverter_on_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk2_actual_values_1_amk2_status_quit_inverter_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk2_actual_values_1_amk2_status_quit_inverter_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk2_actual_values_1_amk2_status_inverter_on_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk2_actual_values_1_amk2_status_inverter_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk2_actual_values_1_amk2_status_inverter_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk2_actual_values_1_amk2_status_derating_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk2_actual_values_1_amk2_status_derating_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk2_actual_values_1_amk2_status_derating_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int16_t can2_amk2_actual_values_1_amk2_actual_velocity_encode(double value)
{
    return (int16_t)(value);
}

double can2_amk2_actual_values_1_amk2_actual_velocity_decode(int16_t value)
{
    return ((double)value);
}

bool can2_amk2_actual_values_1_amk2_actual_velocity_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can2_amk2_actual_values_1_amk2_torque_current_encode(double value)
{
    return (int16_t)(value);
}

double can2_amk2_actual_values_1_amk2_torque_current_decode(int16_t value)
{
    return ((double)value);
}

bool can2_amk2_actual_values_1_amk2_torque_current_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can2_amk2_actual_values_1_amk2_magnetizing_current_encode(double value)
{
    return (int16_t)(value);
}

double can2_amk2_actual_values_1_amk2_magnetizing_current_decode(int16_t value)
{
    return ((double)value);
}

bool can2_amk2_actual_values_1_amk2_magnetizing_current_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can2_amk2_actual_values_2_pack(
    uint8_t *dst_p,
    const struct can2_amk2_actual_values_2_t *src_p,
    size_t size)
{
    uint16_t amk2_temp_igbt;
    uint16_t amk2_temp_inverter;
    uint16_t amk2_temp_motor;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    amk2_temp_motor = (uint16_t)src_p->amk2_temp_motor;
    dst_p[0] |= pack_left_shift_u16(amk2_temp_motor, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(amk2_temp_motor, 8u, 0xffu);
    amk2_temp_inverter = (uint16_t)src_p->amk2_temp_inverter;
    dst_p[2] |= pack_left_shift_u16(amk2_temp_inverter, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(amk2_temp_inverter, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->amk2_error_info, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->amk2_error_info, 8u, 0xffu);
    amk2_temp_igbt = (uint16_t)src_p->amk2_temp_igbt;
    dst_p[6] |= pack_left_shift_u16(amk2_temp_igbt, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(amk2_temp_igbt, 8u, 0xffu);

    return (8);
}

int can2_amk2_actual_values_2_unpack(
    struct can2_amk2_actual_values_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t amk2_temp_igbt;
    uint16_t amk2_temp_inverter;
    uint16_t amk2_temp_motor;

    if (size < 8u) {
        return (-EINVAL);
    }

    amk2_temp_motor = unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    amk2_temp_motor |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->amk2_temp_motor = (int16_t)amk2_temp_motor;
    amk2_temp_inverter = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    amk2_temp_inverter |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->amk2_temp_inverter = (int16_t)amk2_temp_inverter;
    dst_p->amk2_error_info = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->amk2_error_info |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    amk2_temp_igbt = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    amk2_temp_igbt |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->amk2_temp_igbt = (int16_t)amk2_temp_igbt;

    return (0);
}

int16_t can2_amk2_actual_values_2_amk2_temp_motor_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can2_amk2_actual_values_2_amk2_temp_motor_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can2_amk2_actual_values_2_amk2_temp_motor_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t can2_amk2_actual_values_2_amk2_temp_inverter_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can2_amk2_actual_values_2_amk2_temp_inverter_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can2_amk2_actual_values_2_amk2_temp_inverter_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint16_t can2_amk2_actual_values_2_amk2_error_info_encode(double value)
{
    return (uint16_t)(value);
}

double can2_amk2_actual_values_2_amk2_error_info_decode(uint16_t value)
{
    return ((double)value);
}

bool can2_amk2_actual_values_2_amk2_error_info_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int16_t can2_amk2_actual_values_2_amk2_temp_igbt_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double can2_amk2_actual_values_2_amk2_temp_igbt_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool can2_amk2_actual_values_2_amk2_temp_igbt_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int can2_amk2_setpoints_1_pack(
    uint8_t *dst_p,
    const struct can2_amk2_setpoints_1_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[1] |= pack_left_shift_u8(src_p->amk2_control_inverter_on, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk2_control_dc_on, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk2_control_enable, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->amk2_control_error_reset, 3u, 0x08u);
    dst_p[2] |= pack_left_shift_u16(src_p->amk2_target_velocity, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->amk2_target_velocity, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->amk2_torque_limit_positiv, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->amk2_torque_limit_positiv, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->amk2_torque_limit_negativ, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->amk2_torque_limit_negativ, 8u, 0xffu);

    return (8);
}

int can2_amk2_setpoints_1_unpack(
    struct can2_amk2_setpoints_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    dst_p->amk2_control_inverter_on = unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->amk2_control_dc_on = unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->amk2_control_enable = unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->amk2_control_error_reset = unpack_right_shift_u8(src_p[1], 3u, 0x08u);
    dst_p->amk2_target_velocity = unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->amk2_target_velocity |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->amk2_torque_limit_positiv = unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->amk2_torque_limit_positiv |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->amk2_torque_limit_negativ = unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->amk2_torque_limit_negativ |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint8_t can2_amk2_setpoints_1_amk2_control_inverter_on_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk2_setpoints_1_amk2_control_inverter_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk2_setpoints_1_amk2_control_inverter_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk2_setpoints_1_amk2_control_dc_on_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk2_setpoints_1_amk2_control_dc_on_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk2_setpoints_1_amk2_control_dc_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk2_setpoints_1_amk2_control_enable_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk2_setpoints_1_amk2_control_enable_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk2_setpoints_1_amk2_control_enable_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_amk2_setpoints_1_amk2_control_error_reset_encode(double value)
{
    return (uint8_t)(value);
}

double can2_amk2_setpoints_1_amk2_control_error_reset_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_amk2_setpoints_1_amk2_control_error_reset_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint16_t can2_amk2_setpoints_1_amk2_target_velocity_encode(double value)
{
    return (uint16_t)(value);
}

double can2_amk2_setpoints_1_amk2_target_velocity_decode(uint16_t value)
{
    return ((double)value);
}

bool can2_amk2_setpoints_1_amk2_target_velocity_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can2_amk2_setpoints_1_amk2_torque_limit_positiv_encode(double value)
{
    return (uint16_t)(value);
}

double can2_amk2_setpoints_1_amk2_torque_limit_positiv_decode(uint16_t value)
{
    return ((double)value);
}

bool can2_amk2_setpoints_1_amk2_torque_limit_positiv_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t can2_amk2_setpoints_1_amk2_torque_limit_negativ_encode(double value)
{
    return (uint16_t)(value);
}

double can2_amk2_setpoints_1_amk2_torque_limit_negativ_decode(uint16_t value)
{
    return ((double)value);
}

bool can2_amk2_setpoints_1_amk2_torque_limit_negativ_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int can2_amk3_actual_values_1_pack(
    uint8_t *dst_p,
    const struct can2_amk3_actual_values_1_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int can2_amk3_actual_values_1_unpack(
    struct can2_amk3_actual_values_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int can2_amk3_actual_values_2_pack(
    uint8_t *dst_p,
    const struct can2_amk3_actual_values_2_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int can2_amk3_actual_values_2_unpack(
    struct can2_amk3_actual_values_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int can2_amk3_setpoints_1_pack(
    uint8_t *dst_p,
    const struct can2_amk3_setpoints_1_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int can2_amk3_setpoints_1_unpack(
    struct can2_amk3_setpoints_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int can2_amk4_actual_values_1_pack(
    uint8_t *dst_p,
    const struct can2_amk4_actual_values_1_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int can2_amk4_actual_values_1_unpack(
    struct can2_amk4_actual_values_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int can2_amk4_actual_values_2_pack(
    uint8_t *dst_p,
    const struct can2_amk4_actual_values_2_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int can2_amk4_actual_values_2_unpack(
    struct can2_amk4_actual_values_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int can2_amk4_setpoints_1_pack(
    uint8_t *dst_p,
    const struct can2_amk4_setpoints_1_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int can2_amk4_setpoints_1_unpack(
    struct can2_amk4_setpoints_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int can2_ivt_msg_command_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_command_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int can2_ivt_msg_command_unpack(
    struct can2_ivt_msg_command_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int can2_ivt_msg_response_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_response_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int can2_ivt_msg_response_unpack(
    struct can2_ivt_msg_response_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    return (0);
}

int can2_ivt_msg_result_i_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_i_t *src_p,
    size_t size)
{
    uint64_t i_ts;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    i_ts = (uint64_t)src_p->i_ts;
    dst_p[0] |= pack_right_shift_u64(i_ts, 40u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(i_ts, 32u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(i_ts, 24u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(i_ts, 16u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(i_ts, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u64(i_ts, 0u, 0xffu);

    return (6);
}

int can2_ivt_msg_result_i_unpack(
    struct can2_ivt_msg_result_i_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint64_t i_ts;

    if (size < 6u) {
        return (-EINVAL);
    }

    i_ts = unpack_left_shift_u64(src_p[0], 40u, 0xffu);
    i_ts |= unpack_left_shift_u64(src_p[1], 32u, 0xffu);
    i_ts |= unpack_left_shift_u64(src_p[2], 24u, 0xffu);
    i_ts |= unpack_left_shift_u64(src_p[3], 16u, 0xffu);
    i_ts |= unpack_left_shift_u64(src_p[4], 8u, 0xffu);
    i_ts |= unpack_right_shift_u64(src_p[5], 0u, 0xffu);

    if ((i_ts & (1ull << 47)) != 0ull) {
        i_ts |= 0xffff000000000000ull;
    }

    dst_p->i_ts = (int64_t)i_ts;

    return (0);
}

int64_t can2_ivt_msg_result_i_i_ts_encode(double value)
{
    return (int64_t)(value / 0.001);
}

double can2_ivt_msg_result_i_i_ts_decode(int64_t value)
{
    return ((double)value * 0.001);
}

bool can2_ivt_msg_result_i_i_ts_is_in_range(int64_t value)
{
    return ((value >= -140737488355328ll) && (value <= 140737488355327ll));
}

int can2_ivt_msg_result_u1_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_u1_t *src_p,
    size_t size)
{
    uint64_t u_cells;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    u_cells = (uint64_t)src_p->u_cells;
    dst_p[0] |= pack_right_shift_u64(u_cells, 40u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(u_cells, 32u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(u_cells, 24u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(u_cells, 16u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(u_cells, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u64(u_cells, 0u, 0xffu);

    return (6);
}

int can2_ivt_msg_result_u1_unpack(
    struct can2_ivt_msg_result_u1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint64_t u_cells;

    if (size < 6u) {
        return (-EINVAL);
    }

    u_cells = unpack_left_shift_u64(src_p[0], 40u, 0xffu);
    u_cells |= unpack_left_shift_u64(src_p[1], 32u, 0xffu);
    u_cells |= unpack_left_shift_u64(src_p[2], 24u, 0xffu);
    u_cells |= unpack_left_shift_u64(src_p[3], 16u, 0xffu);
    u_cells |= unpack_left_shift_u64(src_p[4], 8u, 0xffu);
    u_cells |= unpack_right_shift_u64(src_p[5], 0u, 0xffu);

    if ((u_cells & (1ull << 47)) != 0ull) {
        u_cells |= 0xffff000000000000ull;
    }

    dst_p->u_cells = (int64_t)u_cells;

    return (0);
}

int64_t can2_ivt_msg_result_u1_u_cells_encode(double value)
{
    return (int64_t)(value / 0.001);
}

double can2_ivt_msg_result_u1_u_cells_decode(int64_t value)
{
    return ((double)value * 0.001);
}

bool can2_ivt_msg_result_u1_u_cells_is_in_range(int64_t value)
{
    return ((value >= -140737488355328ll) && (value <= 140737488355327ll));
}

int can2_ivt_msg_result_u2_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_u2_t *src_p,
    size_t size)
{
    uint64_t u_fuse;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    u_fuse = (uint64_t)src_p->u_fuse;
    dst_p[0] |= pack_right_shift_u64(u_fuse, 40u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(u_fuse, 32u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(u_fuse, 24u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(u_fuse, 16u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(u_fuse, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u64(u_fuse, 0u, 0xffu);

    return (6);
}

int can2_ivt_msg_result_u2_unpack(
    struct can2_ivt_msg_result_u2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint64_t u_fuse;

    if (size < 6u) {
        return (-EINVAL);
    }

    u_fuse = unpack_left_shift_u64(src_p[0], 40u, 0xffu);
    u_fuse |= unpack_left_shift_u64(src_p[1], 32u, 0xffu);
    u_fuse |= unpack_left_shift_u64(src_p[2], 24u, 0xffu);
    u_fuse |= unpack_left_shift_u64(src_p[3], 16u, 0xffu);
    u_fuse |= unpack_left_shift_u64(src_p[4], 8u, 0xffu);
    u_fuse |= unpack_right_shift_u64(src_p[5], 0u, 0xffu);

    if ((u_fuse & (1ull << 47)) != 0ull) {
        u_fuse |= 0xffff000000000000ull;
    }

    dst_p->u_fuse = (int64_t)u_fuse;

    return (0);
}

int64_t can2_ivt_msg_result_u2_u_fuse_encode(double value)
{
    return (int64_t)(value / 0.001);
}

double can2_ivt_msg_result_u2_u_fuse_decode(int64_t value)
{
    return ((double)value * 0.001);
}

bool can2_ivt_msg_result_u2_u_fuse_is_in_range(int64_t value)
{
    return ((value >= -140737488355328ll) && (value <= 140737488355327ll));
}

int can2_ivt_msg_result_u3_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_u3_t *src_p,
    size_t size)
{
    uint64_t u_vehicle;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    u_vehicle = (uint64_t)src_p->u_vehicle;
    dst_p[0] |= pack_right_shift_u64(u_vehicle, 40u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(u_vehicle, 32u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(u_vehicle, 24u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(u_vehicle, 16u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(u_vehicle, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u64(u_vehicle, 0u, 0xffu);

    return (6);
}

int can2_ivt_msg_result_u3_unpack(
    struct can2_ivt_msg_result_u3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint64_t u_vehicle;

    if (size < 6u) {
        return (-EINVAL);
    }

    u_vehicle = unpack_left_shift_u64(src_p[0], 40u, 0xffu);
    u_vehicle |= unpack_left_shift_u64(src_p[1], 32u, 0xffu);
    u_vehicle |= unpack_left_shift_u64(src_p[2], 24u, 0xffu);
    u_vehicle |= unpack_left_shift_u64(src_p[3], 16u, 0xffu);
    u_vehicle |= unpack_left_shift_u64(src_p[4], 8u, 0xffu);
    u_vehicle |= unpack_right_shift_u64(src_p[5], 0u, 0xffu);

    if ((u_vehicle & (1ull << 47)) != 0ull) {
        u_vehicle |= 0xffff000000000000ull;
    }

    dst_p->u_vehicle = (int64_t)u_vehicle;

    return (0);
}

int64_t can2_ivt_msg_result_u3_u_vehicle_encode(double value)
{
    return (int64_t)(value / 0.001);
}

double can2_ivt_msg_result_u3_u_vehicle_decode(int64_t value)
{
    return ((double)value * 0.001);
}

bool can2_ivt_msg_result_u3_u_vehicle_is_in_range(int64_t value)
{
    return ((value >= -140737488355328ll) && (value <= 140737488355327ll));
}

int can2_ivt_msg_result_t_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_t_t *src_p,
    size_t size)
{
    uint64_t ivt_temperature;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    ivt_temperature = (uint64_t)src_p->ivt_temperature;
    dst_p[0] |= pack_right_shift_u64(ivt_temperature, 40u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(ivt_temperature, 32u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(ivt_temperature, 24u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(ivt_temperature, 16u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(ivt_temperature, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u64(ivt_temperature, 0u, 0xffu);

    return (6);
}

int can2_ivt_msg_result_t_unpack(
    struct can2_ivt_msg_result_t_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint64_t ivt_temperature;

    if (size < 6u) {
        return (-EINVAL);
    }

    ivt_temperature = unpack_left_shift_u64(src_p[0], 40u, 0xffu);
    ivt_temperature |= unpack_left_shift_u64(src_p[1], 32u, 0xffu);
    ivt_temperature |= unpack_left_shift_u64(src_p[2], 24u, 0xffu);
    ivt_temperature |= unpack_left_shift_u64(src_p[3], 16u, 0xffu);
    ivt_temperature |= unpack_left_shift_u64(src_p[4], 8u, 0xffu);
    ivt_temperature |= unpack_right_shift_u64(src_p[5], 0u, 0xffu);

    if ((ivt_temperature & (1ull << 47)) != 0ull) {
        ivt_temperature |= 0xffff000000000000ull;
    }

    dst_p->ivt_temperature = (int64_t)ivt_temperature;

    return (0);
}

int64_t can2_ivt_msg_result_t_ivt_temperature_encode(double value)
{
    return (int64_t)(value / 0.1);
}

double can2_ivt_msg_result_t_ivt_temperature_decode(int64_t value)
{
    return ((double)value * 0.1);
}

bool can2_ivt_msg_result_t_ivt_temperature_is_in_range(int64_t value)
{
    return ((value >= -140737488355328ll) && (value <= 140737488355327ll));
}

int can2_ivt_msg_result_w_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_w_t *src_p,
    size_t size)
{
    uint64_t w_ts;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    w_ts = (uint64_t)src_p->w_ts;
    dst_p[0] |= pack_right_shift_u64(w_ts, 40u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(w_ts, 32u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(w_ts, 24u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(w_ts, 16u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(w_ts, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u64(w_ts, 0u, 0xffu);

    return (6);
}

int can2_ivt_msg_result_w_unpack(
    struct can2_ivt_msg_result_w_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint64_t w_ts;

    if (size < 6u) {
        return (-EINVAL);
    }

    w_ts = unpack_left_shift_u64(src_p[0], 40u, 0xffu);
    w_ts |= unpack_left_shift_u64(src_p[1], 32u, 0xffu);
    w_ts |= unpack_left_shift_u64(src_p[2], 24u, 0xffu);
    w_ts |= unpack_left_shift_u64(src_p[3], 16u, 0xffu);
    w_ts |= unpack_left_shift_u64(src_p[4], 8u, 0xffu);
    w_ts |= unpack_right_shift_u64(src_p[5], 0u, 0xffu);

    if ((w_ts & (1ull << 47)) != 0ull) {
        w_ts |= 0xffff000000000000ull;
    }

    dst_p->w_ts = (int64_t)w_ts;

    return (0);
}

int64_t can2_ivt_msg_result_w_w_ts_encode(double value)
{
    return (int64_t)(value);
}

double can2_ivt_msg_result_w_w_ts_decode(int64_t value)
{
    return ((double)value);
}

bool can2_ivt_msg_result_w_w_ts_is_in_range(int64_t value)
{
    return ((value >= -140737488355328ll) && (value <= 140737488355327ll));
}

int can2_ivt_msg_result_as_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_as_t *src_p,
    size_t size)
{
    uint64_t tsa_available_capacity;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    tsa_available_capacity = (uint64_t)src_p->tsa_available_capacity;
    dst_p[0] |= pack_right_shift_u64(tsa_available_capacity, 40u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(tsa_available_capacity, 32u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(tsa_available_capacity, 24u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(tsa_available_capacity, 16u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(tsa_available_capacity, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u64(tsa_available_capacity, 0u, 0xffu);

    return (6);
}

int can2_ivt_msg_result_as_unpack(
    struct can2_ivt_msg_result_as_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint64_t tsa_available_capacity;

    if (size < 6u) {
        return (-EINVAL);
    }

    tsa_available_capacity = unpack_left_shift_u64(src_p[0], 40u, 0xffu);
    tsa_available_capacity |= unpack_left_shift_u64(src_p[1], 32u, 0xffu);
    tsa_available_capacity |= unpack_left_shift_u64(src_p[2], 24u, 0xffu);
    tsa_available_capacity |= unpack_left_shift_u64(src_p[3], 16u, 0xffu);
    tsa_available_capacity |= unpack_left_shift_u64(src_p[4], 8u, 0xffu);
    tsa_available_capacity |= unpack_right_shift_u64(src_p[5], 0u, 0xffu);

    if ((tsa_available_capacity & (1ull << 47)) != 0ull) {
        tsa_available_capacity |= 0xffff000000000000ull;
    }

    dst_p->tsa_available_capacity = (int64_t)tsa_available_capacity;

    return (0);
}

int64_t can2_ivt_msg_result_as_tsa_available_capacity_encode(double value)
{
    return (int64_t)(value);
}

double can2_ivt_msg_result_as_tsa_available_capacity_decode(int64_t value)
{
    return ((double)value);
}

bool can2_ivt_msg_result_as_tsa_available_capacity_is_in_range(int64_t value)
{
    return ((value >= -140737488355328ll) && (value <= 140737488355327ll));
}

int can2_ivt_msg_result_wh_pack(
    uint8_t *dst_p,
    const struct can2_ivt_msg_result_wh_t *src_p,
    size_t size)
{
    uint64_t tsa_used_energy;

    if (size < 6u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 6);

    tsa_used_energy = (uint64_t)src_p->tsa_used_energy;
    dst_p[0] |= pack_right_shift_u64(tsa_used_energy, 40u, 0xffu);
    dst_p[1] |= pack_right_shift_u64(tsa_used_energy, 32u, 0xffu);
    dst_p[2] |= pack_right_shift_u64(tsa_used_energy, 24u, 0xffu);
    dst_p[3] |= pack_right_shift_u64(tsa_used_energy, 16u, 0xffu);
    dst_p[4] |= pack_right_shift_u64(tsa_used_energy, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u64(tsa_used_energy, 0u, 0xffu);

    return (6);
}

int can2_ivt_msg_result_wh_unpack(
    struct can2_ivt_msg_result_wh_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint64_t tsa_used_energy;

    if (size < 6u) {
        return (-EINVAL);
    }

    tsa_used_energy = unpack_left_shift_u64(src_p[0], 40u, 0xffu);
    tsa_used_energy |= unpack_left_shift_u64(src_p[1], 32u, 0xffu);
    tsa_used_energy |= unpack_left_shift_u64(src_p[2], 24u, 0xffu);
    tsa_used_energy |= unpack_left_shift_u64(src_p[3], 16u, 0xffu);
    tsa_used_energy |= unpack_left_shift_u64(src_p[4], 8u, 0xffu);
    tsa_used_energy |= unpack_right_shift_u64(src_p[5], 0u, 0xffu);

    if ((tsa_used_energy & (1ull << 47)) != 0ull) {
        tsa_used_energy |= 0xffff000000000000ull;
    }

    dst_p->tsa_used_energy = (int64_t)tsa_used_energy;

    return (0);
}

int64_t can2_ivt_msg_result_wh_tsa_used_energy_encode(double value)
{
    return (int64_t)(value);
}

double can2_ivt_msg_result_wh_tsa_used_energy_decode(int64_t value)
{
    return ((double)value);
}

bool can2_ivt_msg_result_wh_tsa_used_energy_is_in_range(int64_t value)
{
    return ((value >= -140737488355328ll) && (value <= 140737488355327ll));
}

int can2_charger_config_pack(
    uint8_t *dst_p,
    const struct can2_charger_config_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u8(src_p->set_mux, 0u, 0xffu);

    switch (src_p->set_mux) {

    case 64:
        dst_p[1] |= pack_right_shift_u16(src_p->msg_set_voltage_limit, 8u, 0xffu);
        dst_p[2] |= pack_left_shift_u16(src_p->msg_set_voltage_limit, 0u, 0xffu);
        break;

    case 65:
        dst_p[1] |= pack_right_shift_u16(src_p->msg_set_current_limit, 8u, 0xffu);
        dst_p[2] |= pack_left_shift_u16(src_p->msg_set_current_limit, 0u, 0xffu);
        break;

    case 66:
        dst_p[1] |= pack_right_shift_u16(src_p->msg_set_power_limit, 8u, 0xffu);
        dst_p[2] |= pack_left_shift_u16(src_p->msg_set_power_limit, 0u, 0xffu);
        break;

    case 68:
        dst_p[2] |= pack_left_shift_u8(src_p->msg_set_enabled, 0u, 0xffu);
        dst_p[3] |= pack_left_shift_u8(src_p->msg_set_time_out, 0u, 0xffu);
        break;

    default:
        break;
    }

    return (4);
}

int can2_charger_config_unpack(
    struct can2_charger_config_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 4u) {
        return (-EINVAL);
    }

    dst_p->set_mux = unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    switch (dst_p->set_mux) {

    case 64:
        dst_p->msg_set_voltage_limit = unpack_left_shift_u16(src_p[1], 8u, 0xffu);
        dst_p->msg_set_voltage_limit |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
        break;

    case 65:
        dst_p->msg_set_current_limit = unpack_left_shift_u16(src_p[1], 8u, 0xffu);
        dst_p->msg_set_current_limit |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
        break;

    case 66:
        dst_p->msg_set_power_limit = unpack_left_shift_u16(src_p[1], 8u, 0xffu);
        dst_p->msg_set_power_limit |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
        break;

    case 68:
        dst_p->msg_set_enabled = unpack_right_shift_u8(src_p[2], 0u, 0xffu);
        dst_p->msg_set_time_out = unpack_right_shift_u8(src_p[3], 0u, 0xffu);
        break;

    default:
        break;
    }

    return (0);
}

uint8_t can2_charger_config_set_mux_encode(double value)
{
    return (uint8_t)(value);
}

double can2_charger_config_set_mux_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_charger_config_set_mux_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t can2_charger_config_msg_set_voltage_limit_encode(double value)
{
    return (uint16_t)(value);
}

double can2_charger_config_msg_set_voltage_limit_decode(uint16_t value)
{
    return ((double)value);
}

bool can2_charger_config_msg_set_voltage_limit_is_in_range(uint16_t value)
{
    return (value <= 900u);
}

uint16_t can2_charger_config_msg_set_current_limit_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double can2_charger_config_msg_set_current_limit_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool can2_charger_config_msg_set_current_limit_is_in_range(uint16_t value)
{
    return (value <= 133u);
}

uint16_t can2_charger_config_msg_set_power_limit_encode(double value)
{
    return (uint16_t)(value);
}

double can2_charger_config_msg_set_power_limit_decode(uint16_t value)
{
    return ((double)value);
}

bool can2_charger_config_msg_set_power_limit_is_in_range(uint16_t value)
{
    return (value <= 2559u);
}

uint8_t can2_charger_config_msg_set_enabled_encode(double value)
{
    return (uint8_t)(value);
}

double can2_charger_config_msg_set_enabled_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_charger_config_msg_set_enabled_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t can2_charger_config_msg_set_time_out_encode(double value)
{
    return (uint8_t)(value);
}

double can2_charger_config_msg_set_time_out_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_charger_config_msg_set_time_out_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int can2_cc_status_pack(
    uint8_t *dst_p,
    const struct can2_cc_status_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->enable_ams_charging, 0u, 0x01u);

    return (1);
}

int can2_cc_status_unpack(
    struct can2_cc_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    dst_p->enable_ams_charging = unpack_right_shift_u8(src_p[0], 0u, 0x01u);

    return (0);
}

uint8_t can2_cc_status_enable_ams_charging_encode(double value)
{
    return (uint8_t)(value);
}

double can2_cc_status_enable_ams_charging_decode(uint8_t value)
{
    return ((double)value);
}

bool can2_cc_status_enable_ams_charging_is_in_range(uint8_t value)
{
    return (value <= 1u);
}
